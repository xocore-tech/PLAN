;;;; Copyright (c) 2026 xoCore Technologies
;;;; SPDX-License-Identifier: MIT
;;;; See LICENSE for full terms.
#### boot

= (Pin i)             | ##0 i
= (Law n a b)         | ##1 n a b
= (Inc m)             | ##2 m
= (Case_ p l a z m o) | ##3 p l a z m o
= (Die x)             | ##die x

(Inc 0 =?= 1)
(Law 0 1 2 =?= (x & 2))
(Pin 0 =?= ##0)
(Case_ {p} {l} {a} {z} {m} 0 =?= {z})
(Case_ {p} {l} {a} {z} {m} (1 2 3) =?= ({a} (1 2) 3))

= (PlanCase p l a n x) | Case_ p l a n _&n x
= (NatCase z p x)      | Case_ _&z (_ _ _)&z (_ _)&z z p x
= (Force x)            | Law 0 1 0-x 0
= (Seq x y)            | NatCase y _&y x
= (DeepSeq x y)        | Seq (Force x) y
= (Trace x y)          | DeepSeq x y
= (DeepTrace x y)      | DeepSeq x y
= (IsPin x)            | PlanCase _&1     (_ _ _)&0         (_ _)&0 0 x
= (IsLaw x)            | PlanCase _&0     (_ _ _)&1         (_ _)&0 0 x
= (IsApp x)            | PlanCase _&0     (_ _ _)&0         (_ _)&1 0 x
= (IsNat x)            | PlanCase _&0     (_ _ _)&0         (_ _)&0 1 x
= (PlanTag x)          | PlanCase _&0     (_ _ _)&1         (_ _)&2 3 x
= (PinItem x)          | PlanCase i&i     (_ _ _)&0         (_ _)&0 0 x
= (LawName x)          | PlanCase _&0     (i _ _)&i         (_ _)&0 0 x
= (LawArgs x)          | PlanCase _&0     (_ i _)&i         (_ _)&0 0 x
= (LawBody x)          | PlanCase _&0     (_ _ i)&i         (_ _)&0 0 x
= (Car x)              | PlanCase _&(##0) (n a _)&(##1 n a) (h _)&h 0 x
= (Cdr x)              | PlanCase i&i     (_ _ b)&b         (_ t)&t 0 x
= (Eqz x)              | Case_ _&0 (_ _ _)&0 (_ _)&0 1 _&0 x
= (Eq1 x)              | NatCase 0 Eqz x
= (Eq2 x)              | NatCase 0 Eq1 x
= (Strict n x)         | NatCase x m&(Seq x Strict-m) n
= (traceId x)          | Trace x x
= (deepTraceId x)      | DeepTrace x x
= (**traced tag x)     | Trace (0 tag x) x
= dTrk                 | DeepTrace
= trk                  | Trace

(TRUE = 1)(FALSE = 0)

= (If x t e)  | NatCase t _&e (Eqz x)
= (Ifz x t e) | If x e t
= (Not x)     | If x 0 1
= (Bit x)     | If x 1 0
= (And x y)   | If x y x
= (Or x y)    | If x x y
= (Xor x y)   | If x (Not y) y
= (Nand x y)  | If x (Not y) 1
= (Nor x y)   | If x 0 (Not y)
= (Xnor x y)  | If x y (Not y)
= (**else x)  | x

= (Nat x)       | NatCase 0 Inc x
= (Dec x)       | NatCase 0 i&i x
= (Times f z x) | NatCase z (Times f f-z) x
= (Add x y)     | Times Inc (Nat x) y
= (Mul x y)     | Times (Add x) 0 y
= (Sub x y)     | Times Dec (Nat x) y
= (Pow b p)     | Times (Mul b) 1 p
= (Bex p)       | Pow 2 p

(LT = 0)(EQ = 1)(GT = 2)

= (OrdWeld x y) | If (Eq1 x) y x
= (natLte x y)  | Not (Sub x y)
= (natLth x y)  | natLte Inc-x y
= (natGte x y)  | natLte y x
= (natGth x y)  | natLth y x
= (natEql x y)  | And natLte-y-x natLte-x-y
= (natMin x y)  | If natLte-x-y x y
= (natMax x y)  | If natGte-x-y x y
= (natCmp x y)  | natMin 2 (Sub Inc-x y)

= (Div x y)        | If (natLth x y) 0 Inc-(Div (Sub x y) y)
= (Mod x y)        | Sub x (Mul y | Div x y)
= (DivCeil n m)    | Div (Add n | Dec m) m
= (DivMod x y)     | 0 (Div x y) (Mod x y)
= (Lsh v n)        | Mul (Bex n) v
= (Rsh v n)        | Div v (Bex n)
= (Trunc w n)      | Mod n Bex-w
= (BitSlice o w n) | Trunc w (Rsh n o)
= (BitIx i n)      | BitSlice i 1 n
= (BitSz n)        | And n | Inc BitSz-(Div n 2)
= (PopCount n)     | And n | Add (Mod n 2) PopCount-(Div n 2)
= (BitSet i n)     | If  (BitIx i n) n (Add Bex-i n)
= (BitClear i n)   | Ifz (BitIx i n) n (Sub n Bex-i)

= (Sz v)      | And IsApp-v Inc-(Sz Car-v)
= (bruh r i)  | Cdr (Times Car r i)
= (Br i r f)  | NatCase f (bruh r) (Sub Sz-r i)
= (Ix i r)    | Br i r 0
= (opp v r i) | Ifz i (Car r v) (opp v Car-r Dec-i Cdr-r)
= (Up i v r)  | NatCase r (opp v r) (Sub Sz-r i)
= (Hd x)      | Ifz IsApp-x x Hd-(Car x)
= (Last xs)   | And IsApp-xs Cdr-xs
= (Null x)    | Not IsApp-x

= (Coup x o) | ##3 _&x (_ _ _)&x (h t)&(Coup x h t) x _&x o

(Coup 3   4     =?= 3)
(Coup 3   (4 5) =?= 3 5)
(Coup 3   ##4   =?= 3)
(Coup Mul Add-1 =?= Mul-1)

(OrdTag x)=(PlanCase _&1 (_ _ _)&2 (_ _)&3 0 x)

= (Cmp x y)
@ ox OrdTag-x
| OrdWeld (natCmp ox OrdTag-y)
@ natCase | natCmp x y
@ pinCase | Cmp PinItem-x PinItem-y
@ appCase | OrdWeld (Cmp Car-x Car-y) (Cmp Cdr-x Cdr-y)
@ lawCase | OrdWeld (natCmp LawName-x LawName-y)
          | OrdWeld (natCmp LawArgs-x LawArgs-y)
                    (Cmp LawBody-x LawBody-y)
| Ix ox (0 natCase pinCase lawCase appCase)

= (Lth x y) | Eqz (Cmp x y)
= (Eql x y) | Eq1 (Cmp x y)
= (Gth x y) | Eq2 (Cmp x y)
= (Neq x y) | Not (Eql x y)
= (Lte x y) | Not (Gth x y)
= (Gte x y) | Not (Lth x y)
= (Min x y) | If (Lth x y) x y
= (Max x y) | If (Gth x y) x y

= (Find f x)
^ _ 0 Sz-x
? (go i rem)
| Ifz rem i
| If f-(Ix i x) i
| go Inc-i Dec-rem

= (FindEq e x)        | Find Eql-e x
= (Any f x)           | Neq Sz-x (Find f x)
= (Has e x)           | Neq Sz-x (FindEq e x)
= (Switch ks k bs fb) | Br (FindEq k ks) bs fb

= (Search key row stride low end)
@ mid | Div (Add low end) 2
@ ix  | Mul stride mid
| If (Gte low end) (Mul ix 2)
| Ix | Cmp key (Ix ix row)
| 0
  (Search key row stride low mid)
  (Inc | Mul ix 2)
  (Search key row stride Inc-mid end)

= (searchSet key row) | Search key row 1 0 Sz-row
= (searchTab key row) | Search key row 2 0 (Div Sz-row 2)

= (foldr f z row)
^ _ 0 Sz-row
? (go i rem)
| Ifz rem z
| f (Ix i row)
| go (Inc i) (Dec rem)

= (foldri f z row)
^ _ 0 Sz-row
? (go i rem)
| Ifz rem z
| f i (Ix i row)
| go (Inc i) (Dec rem)

= (foldl f z row)
^ _ z 0 Sz-row
? (go acc i rem)
| Seq i
| Seq acc
| Ifz rem acc
| go (f acc | Ix i row) (Inc i) (Dec rem)

= (Gen n f)
^ _ Nat-n
? (go i)
| And i (go Dec-i | f Dec-i)

= (Weld x y)
@ xw | Sz x
@ yw | Sz y
| Gen (Add xw yw)
& i
| If (Lth i xw) (Ix i x)
| Ix (Sub i xw) y

= (Insert ix val row)
| Gen (Inc Sz-row)
& i
| Ix (Cmp i ix)
| 0 (Ix i row) val (Ix Dec-i row)

= (Splice at new old)
| Gen (Add Sz-new Sz-old)
& i
@ j     | Sub i at
@ newSz | Sz new
| If (Lth i at)    (Ix i old)
| If (Lth j newSz) (Ix j new)
| Ix (Sub i newSz) old

= (Map f v)       | Gen Sz-v x&(f | Ix x v)
= (Rev row)       | (wid @ Sz row)(Gen wid i&(Ix (Sub wid Inc-i) row))
= fst             | Ix 0
= snd             | Ix 1
= thr             | Ix 2
= (Cons x xs)     | Weld (0 x) xs
= (Snoc xs x)     | Weld xs (0 x)
= (**put r i v)   | Up i v r
= (**get r i)     | Ix i r
= (**foreach x f) | Map f x
= (Rep i n)       | Gen n _&i
= (rowAnd v)      | foldr And TRUE v
= (sum v)         | foldl Add 0 v
= (all f v)       | rowAnd (Map f v)
= (Cat vs)        | foldl Weld 0 vs
= (CatMap f r)    | Cat (Map f r)
= (ZipWith f a b) | Gen (Min Sz-a Sz-b) i&(f Ix-i-a Ix-i-b)
= (Zip a b)       | ZipWith 0 a b
= (Slash v s e)   | Gen (Sub e s) i&(get v | Add s i)
= (Slice v s e)   | Slash v s (Min e | Sz v)
= (Drop n v)      | Slice v n (Sz v)
= (Take n v)      | Slice v 0 n

(FillR f l)=(Ifz l f | FillR f snd-l fst-l)

= (Fill f l)
^ _ l f
? (go l acc)
| Ifz l acc
| go snd-l (acc fst-l)

(OpArity i)=(Br i (0 1 3 1 6) 1)

= (Arity x)
@ p | i&(If IsNat-i OpArity-i Arity-i)
@ l | (_ a _)&a
@ a | (f _)&(Dec (Arity f))
@ n 0
| PlanCase p l a n x

(Arity Arity =?= 1)
(Arity ##3 =?= 6)

(c tag)=(tag ##rex)

(WORD = c-{WORD})(TEXT = c-{TEXT})(LINE = c-{LINE})(OPEN = c-{OPEN})
(NEST = c-{NEST})(INFX = c-{INFX})(PREF = c-{PREF})(SHUT = c-{SHUT})
(EMBD = c-{EMBD})

= (rexRune x)      | If (Neq 4 | Sz x) 0 | Ix 1 x
= (rexSetRune r x) | If (Neq 4 | Sz x) x | Up 1 r x
= (rexHeir x)      @ i (Dec Sz-x) | Ifz Dec-i 0 | Ix i x
= (rexSetHeir h x) @ i (Dec Sz-x) | Ifz Dec-i x | Up i h x
= (rexText x)      | If (Neq 3 | Sz x) 0 | Ix 1 x
= (rexSetText t x) | If (Neq 3 | Sz x) x | Up 1 t x
= (rexSons x)      | If (Neq 4 | Sz x) 0 | Ix 2 x
= (rexSetSons s x) | If (Neq 4 | Sz x) x | Up 2 s x
= (rexEmbd x)      | If (Neq 2 | Sz x) 0 | Ix 1 x
= (rexIsEmbd rex)  | Eql 2 Sz-rex
= (rexIsLeaf rex)  | Eql 3 Sz-rex
= (rexIsNode rex)  | Eql 4 Sz-rex
= (rexType rex)    | Ix (Sub Sz-rex 2) (0 {EMBD} {LEAF} {NODE})
= rexStyle         | Hd

= (**rexOpen rex cb)
@ type  | rexType rex
@ style | rexStyle rex
@ rune  | rexRune rex
@ text  | rexText rex
@ embd  | rexEmbd rex
@ sons  | rexSons rex
@ nSon  | Sz sons
@ heir  | rexHeir rex
@ kids  | Ifz heir sons (Snoc sons heir)
@ nKid  | Sz kids
| **cb type style rune text embd sons nSon heir kids nKid

= (rexKids rex)
@ sons (rexSons rex)
@ heir (rexHeir rex)
| Ifz heir sons (Snoc sons heir)

= (varE v)  | WORD v 0
= (txtE t)  | TEXT t 0
= (ctxE nm) | Ifz nm (**txtE nm) (**varE nm)

= (sireErrFmt renderLineNum ss rex msg)
@ ctx (Ix 1 ss)
@ ln  (Ix 4 ss)
@ blk (Ix 5 ss)
| OPEN "#" | 0 varE-{block} | blk
| OPEN "#" | 0 varE-{what}  | rex
| OPEN "#" | 0 varE-{where} | SHUT {:} (0 ctxE-ctx renderLineNum-ln) 0
| OPEN "#" | 0 varE-{why}   | txtE-msg
| 0

= (appE exps)          | If (Eq1 Sz-exps) (fst exps) | NEST {#|} exps 0
= (rowE xs)            | If Null-xs       (EMBD 0)   | appE (Cons EMBD-0 xs)
= (sireErr ss rex msg) | ##SireError (sireErrFmt EMBD ss rex msg)

= ({'} ss rex)
@ args (rexKids rex)
| If (Neq 1 Sz-args) | sireErr ss rex {Expected 1 Parameter}
| 0 ss EMBD-(fst args)

({,} st rex)=(0 st rowE-(rexKids rex))

= ({++} ss rex)
^ (ss, rowE (_ 0 rex))
? (go acc rex)
@ sons               | rexSons rex
@ rune               | rexRune rex
@ itemRex            | If (Eql 1 Sz-sons) (fst sons) (OPEN {|} sons 0)
| Ifz rex            | acc
| If (Neq {++} rune) | acc rex
| If (Null sons)     | sireErr ss rex {usage: (++ x), (++ f x y), etc}
| else               | go (acc itemRex) rexHeir-rex

= (binop val ss rex)
@ kids (rexKids rex)
| If (Neq 2 | Sz kids) | sireErr ss rex {this is a binary operator}
| (ss, appE (EMBD val, fst kids, snd kids))

({&&} = binop And)({||} = binop Or)({::} = binop 0)
({==} = binop Eql)({/=} = binop Neq)

= ({:} ss rex)
@ sons | rexSons rex
@ args | Take Dec-(Sz sons) sons
@ apps | Last sons
@ body | rexHeir rex
| If    | Or Eqz-body | Or (Lth Sz-sons 2) | (Neq "<" rexRune-apps)
    | sireErr ss rex {Invalid use of :}
^ (ss, _)
| OPEN "|" (rexKids apps)
| OPEN "&" ,(NEST "|" args 0)
| body

= (**openPair x k)   | **k (Ix 0 x) (Ix 1 x)
= (**openTriple x k) | **k (Ix 0 x) (Ix 1 x) (Ix 2 x)

= (mapState f row st)
^ foldl _ [st 0] row
& (st_acc x)
: st acc < openPair st_acc
: st x   < openPair (f x st)
| (st, acc x)

(NONE = 0)(SOME = 0)(NIL = 0)(CONS = 0)(LEFT = 0)(RIGHT = 1)

= (**maybeCase mb non som) | Ifz mb non (**som Cdr-mb)
= (**listCase xs nil cons) | Ifz xs nil (**cons Ix-0-xs Ix-1-xs)
= (**eitherCase x l r)     | If Hd-x (**r fst-x) (**l fst-x)

= (listFoldl f z l)
: x xs < listCase l z
@ fzx (f z x)
| Seq fzx
| listFoldl f fzx xs

= (listZipWith f al bl)
: a as < listCase al NIL
: b bs < listCase bl NIL
| CONS (f a b) (listZipWith f as bs)

= (fmapMaybe x f)     | And x | SOME | f | fst x
= (listFoldr f z l)   | listCase l z (x xs)&(f x | listFoldr f z xs)
= (listSing x)        | CONS x 0
= (listMap f l)       | listFoldr (x xs)&(CONS f-x xs) NIL l
= (**listForEach l f) | listMap f l
= (listIdx i l)       | Ifz i fst-l (listIdx Dec-i snd-l)
= (listUnsafeLast l)  | (xs @ snd l)(Ifz xs fst-l | listUnsafeLast xs)
= (listLen l)         | listFoldr (x acc & Inc acc) 0 l
= (listFromRow v)     | foldr 0 NIL v
= (listOr v)          | listFoldr Or 0 v
= (listAny f v)       | listOr listMap-f-v
= (listHas e xs)      | listAny Eql-e xs
= (listEnumFrom n)    | CONS n (listEnumFrom Inc-n)
= (listWeld a b)      | listCase a b (x xs)&(CONS x | listWeld xs b)
= (listCat ls)        | listFoldr listWeld NIL ls
= (listCatMap f r)    | listCat (listMap f r)
= (listZip a b)       | listZipWith 0 a b
= (listFilter f lis)  | listFoldr (x xs)&(Ifz f-x xs | CONS x xs) 0 lis
= (listGenFrom i n f) | And (Lth i n) | CONS f-i | listGenFrom-(Inc i) n f
= (listGen n f)       | listGenFrom 0 n f
= (listRep i n)       | listGen n _&i
= (listIndexed l)     | listZip (listEnumFrom 0) l
= (listRev xs)        | listFoldl (x y & CONS y x) NIL xs
= (listSnoc xs e)     | listCase xs (CONS e NIL) (x xs)&(CONS x | listSnoc xs e)


= (listFindIndex pred xs notFound found)
^ listFoldr _ notFound (listIndexed xs)
& (idxVal rest)
| Ifz (pred | snd idxVal) rest
| found (fst idxVal)

= (dictSearchCase key table notFound found)
@ res | searchTab key table
@ ix  | Div res 2
| Ifz (Mod res 2) notFound
| Seq ix
| found ix (Ix Inc-ix table)

= bstEmpty        | 0
= (**bstSing k v) | [k v 0 0]

= (**bstCase x empty node)
| Ifz x empty
| **node (Ix 0 x) (Ix 1 x) (Ix 2 x) (Ix 3 x)

= (bstWalk x)
: _ _ l r < bstCase x NIL
| listWeld bstWalk-l x::(bstWalk r)

= (bstSearch k x)
: xk xv l r < bstCase x NONE
@ LT | bstSearch k l
@ EQ | SOME xv
@ GT | bstSearch k r
| Br (Cmp k xk) [LT EQ] GT

(**bstSearchCase k t nf f)=(maybeCase (bstSearch k t) nf f)

= (merge x y)
: xk xv xl xr < bstCase x y
: yk yv yl yr < bstCase y x
| [yk yv (merge x yl) yr]

= (bstAlter k f x)
: xk xv l r < bstCase x (maybeCase (f NONE) 0 (bstSing k))
@ LT | [xk xv (bstAlter k f l) r]
@ EQ | maybeCase (f SOME-xv) (merge l r) nv&[k nv l r]
@ GT | [xk xv l (bstAlter k f r)]
| Br (Cmp k xk) [LT EQ] GT

= (bstLoad table)
^ _ 0 (Div (Sz table) 2)
? (go off end)
@ wid      | Sub end off
@ zeroCase | bstEmpty
@ oneCase  @ i (Mul 2 off) | bstSing (Ix i table) (Ix Inc-i table)
| Br wid [zeroCase oneCase]
@ mid   | Add off (Div wid 2)
@ i     | Mul 2 mid
@ k     | Ix i table
@ v     | Ix Inc-i table
@ l     | go off mid
@ r     | go Inc-mid end
| [k v l r]

(bstSave x)=(Fill 0 | listCatMap kv&(fst kv :: (snd kv :: NIL)) bstWalk-x)

= (bstIns k v t)        | bstAlter k (_ & SOME v) t
= (bstPut t k v)        | bstAlter k (_ & SOME v) t
= (bstHas k t)          | IsApp (bstSearch k t)
= (bstIdx k t)          | bstSearchCase k t 0 a&a
= bstIsEmpty            | Eqz
= (bstFromPairsList xs) | listFoldl (t kv & bstIns fst-kv snd-kv t) 0 xs
= (bstUnion x y)        | listFoldl (t kv & bstIns fst-kv snd-kv t) y bstWalk-x

= (PadLen n)      | Dec (BitSz n)
= (unpackSlice s) | If IsNat-s (0, PadLen s, s) s

= (BitFill ss)
^ fst (foldl _ [0 0] ss)
& (data_sz slice)
: data sz    < openPair data_sz
: so ss sd   < openTriple (unpackSlice slice)
@ newSz      | Add sz ss
@ newData    | Add data (Lsh (BitSlice so ss sd) sz)
| Seq newSz
| Seq newData
| [newData newSz]

= (ByteFill ss)
^ BitFill (Map _ ss)
& bs
: off sz data < openTriple bs
| If IsNat-bs bs (Mul 8 off, Mul 8 sz, data)

= (BitFillList ss)  | BitFill (Fill 0 ss)
= (ByteFillList ss) | ByteFill (Fill 0 ss)

= newlineChar    | 10
= (isDigit c)    | And (Gte c {0}) (Lte c {9})
= (isUpper c)    | And (Gte c {A}) (Lte c {Z})
= (isLower c)    | And (Gte c {a}) (Lte c {z})
= (isAlpha c)    | Or isUpper-c isLower-c

= (StrFoldl f z s)
| Ifz s z
| Seq z
@ z (f z (Mod s 256))
| StrFoldl f z (Div s 256)

= (StrFoldr f z s)
| Ifz s z
| f (Mod s 256)
| StrFoldr f z (Div s 256)

= (ByteSz s)       | DivCeil BitSz-s 8
= (StrPad s)       | BitSet (Mul 8 ByteSz-s) s
= (strCat vs)      | ByteFill (Map StrPad vs)
= (strWeld x y)    | strCat [x y]
= (StrAny f s)     | StrFoldr (c k & Or (f c) k) 0 s
= (StrAll f s)     | StrFoldr (c k & And (f c) k) 1 s
= (StrHas c s)     | StrAny (Eql c) s

= (ByteIx i n)
| Ifz i (Mod n 256)
| And n
| ByteIx (Dec i) (Div n 256)

= (strFindIndexOff f off str)
@ wid (ByteSz str)
^ _ off
? (loop ix)
| If (Gte ix wid) wid
| If (f (ByteIx ix str)) ix
| loop (Inc ix)

= (strElemIndexOff byte off bar) | strFindIndexOff (Eql byte) off bar
= (ByteSlice off wid n)          | BitSlice (Mul 8 off) (Mul 8 wid) n
= (ByteTake wid n)               | Trunc (Mul 8 wid) n
= (ByteDrop wid n)               | Rsh n (Mul 8 wid)

= (listDigits num)
| Ifz num {0}::NIL
^ _ num NIL
? (loop mor acc)
| Ifz mor acc
: mor digit < openPair (DivMod mor 10)
| loop mor (Add digit {0})::acc

= (digits num)       | Fill 0 listDigits-num
= (showNat n)        | strCat digits-n
= (natE n)           | WORD (showNat n) 0
= (renderLnNum ln)   | **varE (showNat ln)
= (sireErr ss r msg) | ##SireError (sireErrFmt renderLnNum ss r msg)

= (**gensym st k)
@ nex | Ix 0 st
@ aft | Inc nex
@ st  | Up 0 aft st
@ nm  | varE (strWeld {_g} showNat-nex)
| Strict 3 aft st nm
| **k st nm

(bloodline lis)=(listFoldr (i r & rexSetHeir r i) 0 lis)

= ({#} ss rex)
: _ _ _ text _ _ _ _ kids nKid < rexOpen rex
@ k1          | fst kids
@ text        | rexText k1
| Ifz nKid    | sireErr ss rex } Needs kids>=1
| Ifz text    | sireErr ss k1  } needs to be text
@ name        | strWeld {#} text
@ bindPin     | bstIdx name (Ix 2 ss)
@ macro       | snd (PinItem bindPin)
| Ifz bindPin | sireErr ss rex (strWeld {undefined symbol: #} text)
| macro ss rex

= (isSymbolChar c)
| Or Eql-{_}-c
| Or isAlpha-c isDigit-c

= (strIsSymbol str)
| And str
| And (| Not | isDigit | ByteIx 0 str)
| StrAll isSymbolChar str

= (readSymbol rex err ok)
@ rune (rexRune rex)
@ kids (rexKids rex)
@ nKid (Sz kids)
| If (Eql {.} rune)
    | If (Neq 1 nKid)
        | err rex {Should be .x, .5, .{x}, etc}
    @ kid (Ix 0 kids)
    | Ifz (rexIsLeaf kid)
        | err rex {Should be .x, .5, .{x}, etc}
    | If (Eql {WORD} | rexStyle kid)
        | err rex {TODO: readSymbol should support .foo and .234}
    | ok (rexText kid)
: _ style _ text _ sons nSon heir _ _ < rexOpen rex
| If (Neq {WORD} style) | err rex {expected a bare word}
| If heir               | err rex {unexpected heir}
| Ifz strIsSymbol-text  | err rex {bad symobl character}
| ok text

(readSymbolEx ss rex)=(readSymbol rex (sireErr ss) (x & x))

= (expandPat ss pat val body)
: _ style rune _ _ sons nSon heir _ _ < rexOpen pat
: ss tmp < gensym ss
@ fail   | (sireErr ss pat {invalid pattern})
| If heir fail
^ Switch [{!} {,} {@}] rune _ fail
++  | If (Neq 1 nSon) fail
    ^ (ss, _)
    | OPEN {#@} (tmp, val)
    | OPEN {#|} (EMBD Seq, tmp)
    | OPEN {@}  (fst sons, tmp)
    | body
++  ^ (ss, OPEN {#@} (tmp, val) (foldri _ body sons))
    & (i son heir)
    | OPEN "@" (son, appE (EMBD Ix-i, tmp)) heir
++  | If (Neq 2 nSon) fail
    : alias pat < openPair sons
    | Seq (readSymbolEx ss alias)
    ^ (ss, _)
    | OPEN {#@} (alias, val)
    | OPEN {@}  (pat, alias)
    | body

= ({@} ss rex)
: _ style rune _ _ _ _ heir kids nKid    < rexOpen rex
: pat val body                           < openTriple kids
: _ patStyle patRune _ _ _ _ patHeir _ _ < rexOpen pat
| If (nKid /= 3)                         | sireErr ss rex {expected three kids}
| If (Eql {WORD} patStyle)
    | If patHeir | expandPat ss patHeir val body
    | (ss, rexSetRune {#@} rex)
| expandPat ss pat val body

= (isPattern rex)
@ isStructBind | And (Eql {WORD} rexStyle-rex) Not-(Eqz rexHeir-rex)
| (isStructBind || Has rexRune-rex [{!} {,} {@}])

= (rebindPatternArgs ss args)
^ mapState _ args (ss, NIL)
& (son acc)
@ (ss, rebinds) acc
| Ifz isPattern-son (acc, son)
: ss newArgRex < gensym ss
| ((ss, CONS [son newArgRex] rebinds), newArgRex)

= (wutMacro wutRune ss rex)
@ kids@[sigRex bodyRex] | rexKids rex
@ sigRune               | rexRune sigRex
@ sigSons               | rexSons sigRex
| If (Neq 2 Sz-kids)    | sireErr ss rex "bad lambda"
| If (Neq {|} sigRune)  | sireErr ss rex "bad lambda"
| If rexHeir-sigRex     | sireErr ss sigRex "unexpected heir"
| If (Lth sigSons 2)    | sireErr ss rex "bad lambda"
@ fallback              | (ss, rexSetRune wutRune rex)
@ ([ss rebinds], args)  | rebindPatternArgs ss (Drop 1 sigSons)
| If (Null rebinds)     | fallback
^ (ss, _)
| OPEN wutRune [(NEST {|} (Cons fst-sigSons args) 0)]
^ listFoldr _ bodyRex rebinds
& (rebind heir)
| OPEN "@" rebind heir

({?} = wutMacro {#?})({??} = wutMacro {#??})

= ({&} ss rex)
@ kids@[sigRex bodyRex] | rexKids rex
@ sigRune               | rexRune sigRex
| If (Neq 2 Sz-kids)    | sireErr ss rex "bad lambda"
| If rexHeir-sigRex     | sireErr ss sigRex "unexpected heir"
@ fallback              | (ss, rexSetRune "#&" rex)
| If (Eql {|} sigRune)
    @ [[ss rebinds] args] (rebindPatternArgs ss rexSons-sigRex)
    | If (Null rebinds) fallback
    ^ (ss, _)
    | OPEN "#&" [(NEST {|} args 0)]
    ^ listFoldr _ bodyRex rebinds
    & (rebind heir)
    | OPEN "@" rebind heir
| If (isPattern sigRex)
    : ss newArgRex < gensym ss
    | 0 ss | OPEN "#&" [newArgRex]
           | OPEN "@" [sigRex newArgRex]
           | bodyRex
| fallback

= (unrollTis rex)
@ heir (rexHeir rex)
| Ifz heir                    | listSing rex
| If (Neq (rexRune heir) {=}) | listSing rex
| CONS (rexSetHeir 0 rex)
| unrollTis heir

= (parseDefine ss rex)
: _ _ _ _ _ _ _ heir kids@[sig val] nKid < rexOpen rex
: _ _ sigRune _ _ _ _ _ sigKids sigNKid  < rexOpen sig
^ And (Eql "|" sigRune) | And (Gte sigNKid 2) | And (Eql nKid 2) | _
@ nmRex | fst sigKids
@ nm    | If (Eql {**} rexRune-nmRex) (fst | rexSons nmRex) nmRex
| (nm, sig, val)

= ({=} ss rex)
^ 0 ss | bloodline | listMap _ | unrollTis rex
& rex
@ res@(nm, sig, body) (parseDefine ss rex)
| Ifz res (OPEN "#=" (rexKids rex) 0)
| OPEN {#=} (nm, OPEN {??} [sig body] 0) 0

= (isSireDecimal str) | And str | StrAll isDigit str
= (loadSireDecimal s) | StrFoldl (acc c & Add (Mul 10 acc) (Sub c {0})) 0 s

= (readSimpleKey ss rex)
| If (Or rexHeir-rex Not-(rexIsLeaf rex))
    | sireErr "not a key"
@ txt (rexText rex)
| If (Eql {WORD} rexStyle-rex && isSireDecimal txt)
    | loadSireDecimal txt
| txt

= (readItems ss rex)
| Ifz rex NIL
| If ("-" /= rexRune rex) | sireErr ss rex {Expected a - rune}
| CONS (rexSetHeir 0 rex)
| readItems ss (rexHeir rex)

= (readBranches ss rex)
: item                 < listForEach (readItems ss rex)
@ sons@[keyRex expRex] | rexSons item
| If (Sz sons /= 2)    | sireErr ss rex {expected a key and a value}
| (readSimpleKey ss keyRex, expRex)

= ({#simpleswitch} ss rex)
: _ _ _ _ _ _ _ _ kids nKid < rexOpen rex
@ [_x expr wild armsRex] | kids
| If (Neq 4 nKid)        | sireErr ss {expected four kids}
@ arms | Fill 0 (readBranches ss armsRex)
@ keys | Map fst arms
@ vals | Map snd arms
^ (ss, _)
| appE (EMBD Switch, EMBD keys, expr, rowE vals, wild)

= ({#struct} ss rex)
@ kids   | rexKids rex
@ sign   | Ix 2 kids
@ sKid   | rexKids sign
@ cnstr  | fst sKid
@ fields | Drop 1 sKid
| Ifz  && (Sz kids == 3)
       && (rexRune sign == {|})
        | (Sz sKid)
    | sireErr ss rex {usage: struct#(CONSTRUCTOR field...)}
@ fields
    : field     < foreach fields
    @ fieldKids | rexKids field
    @ nm        | fst fieldKids
    | If   && (rexStyle field == {WORD})
            | (Eqz rexHeir-field)
        field
    | If   && (rexRune field == {/})
           && (Sz fieldKids == 2)
           && (rexStyle nm == {WORD})
            | (Eqz rexHeir-nm)
        nm
    | Die ["bad input" [rex field]]
@ gettersAndSetters
    ^ bloodline (listCat _)
    : [i getterSym] < listForEach (listIndexed | listFromRow fields)
    @ struct    | WORD {_x} 0
    @ newVal    | WORD {_y} 0
    @ setterSym | WORD (strWeld (rexText getterSym) "Set") 0
    | CONS | OPEN "#=" (getterSym, EMBD (Ix i)) 0
    | CONS | OPEN "#=" (setterSym, EMBD (Up i)) 0
    | NIL
^ (ss, _)
@ sig | NEST "|" (Cons (PREF "**" [cnstr] 0) fields) 0
@ bod | rowE fields
| OPEN "#=" [sig bod]
| gettersAndSetters

= ({#simpledata} ss rex)
@ bad | sireErr ss rex {bad #simpledata}
| If (| Neq 2 | Sz | rexSons rex) bad
@ fields
    ^ _ (rexHeir rex)
    ? (loop rex)
    @ sons | rexSons rex
    | Ifz rex NIL
    | If Null-sons bad
    | If ("-" /= rexRune rex) bad
    @ !cnstr | readSymbolEx ss fst-sons
    | cnstr::(loop rexHeir-rex)
^ (ss, bloodline _)
: cnstrNm < listForEach fields
| OPEN "#=" (varE cnstrNm, EMBD cnstrNm) 0

= (readSimpleCaseBranches ss rex)
@ sons      | rexSons rex
@ nSon      | Sz sons
@ lastSon   | Dec nSon
@ valid     | (("-" == rexRune rex) || Gte nSon 2)
| Ifz rex   | NIL
| Ifz valid | sireErr ss rex {expected something like: - FOO a b c | bodyExpr}
@ syms      | Map (readSymbolEx ss) (Take lastSon sons)
| CONS (fst syms, Drop 1 syms, Ix lastSon sons)
| readSimpleCaseBranches ss (rexHeir rex)

(rowMax xs)=(foldl Max 0 xs)
(maxOf f xs)=(rowMax | Map f xs)

= ({#simplecase} ss rex)

    @ kids@[_ expr fallback branchListRex] (rexKids rex)

    | If (Sz kids /= 4) | sireErr ss rex {expected four params}

    @ branches | Fill 0 (readSimpleCaseBranches ss branchListRex)
    @ keys     | Map fst branches
    : ss tmpE  < gensym ss
    @ tagE     | appE (EMBD Hd, tmpE)
    @ fieldVar | i&(varE | strWeld "_f" showNat-i)

    @ fieldBinds
        @ maxNumFields | maxOf [_ fields _]&(Sz fields) branches
        : i < listGen maxNumFields
        | OPEN "#@" (fieldVar i, appE (EMBD Ix-i, tmpE)) 0

    @ bodyExp
        ^ OPEN "#|" (EMBD Switch, EMBD keys, tagE, _, fallback) 0
        ^ rowE (Map _ branches)
        & [_cnstr fields body]
        | bloodline
        | listSnoc
            : [i field] < listForEach (listIndexed (listFromRow fields))
            | OPEN "#@" (varE field, fieldVar i) 0
        | OPEN "#|" [body] 0

    ^ (ss, _)
    | OPEN "#@" (tmpE, expr)
    | bloodline (listSnoc fieldBinds bodyExp)

* # struct (Span a) | SPAN spanLin/a spanOff/Nat spanEnd/Nat spanVal/a
* # struct Line     | LN lineFil/Str lineNum/Nat lineTxt/Str

# simpledata (Lexi a)
- LRUNE
- LWORD
- LWYTE
- LSEMI
- LTEXT
- LFAIL
- LTERM
- LLINE multi/(List (Span ()))
- LNEST isBracket/Bit xs:a

= (**getLexiLine x fb ok)
| If (Hd x /= {LLINE}) fb
| **ok (fst x)

= (lexMany lexOne ln off ctx txt)
@ lexeme@[_ off end tok] (lexOne ln off ctx txt)
^ (lexeme :: _)
| If (tok == LTERM) NIL
| lexMany lexOne ln end ctx txt

= (lexNest lexMany lexOne ln typ ctx off txt)
@ ts  | lexMany lexOne ln (Inc off) ctx txt
@ [_ _ end _] | listUnsafeLast ts
| (ln, off, end, **LNEST typ ts)

= (wordy c)
^ (Gte c {0} && (Lte c {z} && _))
| (Gte c {a} || (Lte c {9} || (Eql {_} c || (Gte c {A} && Lte c {Z}))))

runeChars={!#$%&*+,-./:<=>?@\^`|~'}

(runic c)=(StrHas c runeChars)

= (eatCurly txt o d)
| Ifz d o
@ next (eatCurly txt Inc-o)
# simpleswitch (ByteIx o txt) (next d)
- 0   | o
- "{" | next Inc-d
- "}" | next Dec-d

= (eatCord txt o)
^ Min (ByteSz txt) (Inc _)
| strElemIndexOff {"} Inc-o txt

= (lexUgly ln off txt)
@ start   | Inc-off
@ delim   | ByteIx start txt
@ lineStr | [ln off ByteSz-txt LLINE-NIL]
@ noMatch
    ^ [ln off _ LTEXT]
    ^ Min (ByteSz txt) (Inc _)
    | strElemIndexOff delim (Inc start) txt
# simpleswitch delim noMatch
- 0   | lineStr
- { } | lineStr

= (lexOne ln o ctx txt)
@ eat | strFindIndexOff
@ c   | ByteIx o txt
^ # simpleswitch c _
  - {(}       | lexNest lexMany lexOne ln FALSE {)} o txt
  - {[}       | lexNest lexMany lexOne ln TRUE  {]} o txt
  - "}"       | lexUgly ln o txt
  - "{"       | (ln, o, eatCurly txt Inc-o 1,      LTEXT)
  - 0         | (ln, o, ByteSz txt,                LTERM)
  - {;}       | (ln, o, ByteSz txt,                LSEMI)
  - {"}       | (ln, o, eatCord txt o,             LTEXT)
  - { }       | (ln, o, eat (Neq 32)        o txt, LWYTE)
| If wordy-c | (ln, o, eat c&(Not wordy-c) o txt, LWORD)
| If runic-c | (ln, o, eat c&(Not runic-c) o txt, LRUNE)
| If ctx==c  | (ln, o, Inc o,                     LTERM)
| else       | (ln, o, Inc o,                     LFAIL)

(lexLine ln)=(lexMany lexOne ln 0 0 (lineTxt ln))

= (multiLine topLs)
: a@SPAN[aLin aOff aEnd aTok] ls < listCase topLs NIL
@ fb (a :: multiLine ls)
: b@SPAN[____ bOff bEnd bTok] ls < listCase ls    fb
: aExtra < **getLexiLine aTok fb
| If (bTok /= LTERM) fb
@ onMatch
    & (newTok more)
    @ aTok | LLINE (spanValSet 0 newTok :: aExtra)
    | multiLine (SPAN aLin aOff aEnd aTok)::more
: c@SPAN[_ cOff cEnd cTok] ls < listCase ls fb
# simplecase cTok fb
- LLINE _ | If (aOff/=cOff) fb
          | onMatch c ls
- LWYTE   : d@SPAN[_ dOff dEnd dTok] ls < listCase ls fb
          : _ < **getLexiLine dTok fb
          | If (aOff/=dOff) fb
          | onMatch d ls

= (mkClump xs)
@ SPAN[lin off _   _] (fst xs)
@ SPAN[_   _   end _] (Last xs)
| (**SPAN lin off end xs)

= (lexiIsSpace tok)  | Has tok [LWYTE LSEMI LTERM]
= (elemIsSpace elem) | lexiIsSpace (spanVal elem)

= (isEndOfCluster ls)
: l ls < listCase ls FALSE
| Or (elemIsSpace l)
| And (spanVal l == LRUNE)
: l ls < listCase ls TRUE
| elemIsSpace l

= (clumpLoop acc remain)
: next more < listCase remain | If acc==NIL NIL
                              | listSing mkClump-(FillR 0 acc)
| If (acc==NIL && elemIsSpace next)
    | clumpLoop acc more
| If (acc/=NIL && isEndOfCluster remain)
    | **CONS mkClump-(FillR 0 acc)
    | clumpLoop NIL remain
| clumpLoop next::acc more

= (clump lexemes)
^ Fill 0 | clumpLoop NIL | listMap _ lexemes
& span@SPAN[l o e x]
| **SPAN l o e
| If (Hd x /= {LNEST}) x
| **LNEST fst-x (clump snd-x)

I=0

# simpledata Tree
- TLEAF Clump
- TNODE Str (Row Tree) (Maybe Tree)

# simpledata (Frag a)
- WOLF Str a
- LAMB a

(**getWolf frag fb onWolf)=(# simplecase frag fb)(- WOLF x y | **onWolf x y)

(spanTxt s@SPAN[lin off end _])=(ByteSlice off (Sub end off) lineTxt-lin)

= (spanFrag s@SPAN[lin off end val])
| If (val /= LRUNE) (LAMB s)
| WOLF (spanTxt s) s

= (clumpFrag c@SPAN[_ off _ es])
@ lamb | (off, LAMB c)
| If (Sz es /= 1) lamb
: rune _ < getWolf (spanFrag fst-es) lamb
(Dec (Add off ByteSz-rune), WOLF rune c)

= (fTree frag)
# simplecase frag 0
- LAMB c   | TLEAF c
- WOLF b _ | TNODE b [] NONE

= (iTree item@I[t x k])
| Ifz t ({invalid item} item)
| TNODE t (FillR 0 x) k

= (merge [rp r] [ip i@I[t cs mHeir]])
: k < maybeCase mHeir | If (rp == ip) | ( ip, I t cs    SOME-r )
                      | else          | ( ip, I t r::cs NONE   )
| (ip, I t (k::cs) (SOME r))

(pairMap f [x y])=[x (f y)]

= (close pos stk)
: i more < listCase stk NIL
| If (Gte pos | fst i) stk
: j k < listCase more | Die {indent too small.  Bug in block splitter}
| close pos (merge (pairMap iTree i) j :: k)


= (pushOnto stk (fragPos, frag))
@ stk@[i is] (close fragPos stk)
: r _ < getWolf frag (merge (fragPos, fTree frag) i :: is)
| (fragPos, I r NIL NONE)::stk

= (pushAll pf fs)          | listFoldl pushOnto (listSing pf) fs
= (forceMerge a b)         | merge (pairMap iTree a) b
= (nonemptyFoldl f [x xs]) | listFoldl f x xs

= (layout frags)
: f@[pos frag] fs < listCase frags NIL
# simplecase frag 0
- LAMB _   | (fTree frag :: layout fs)
- WOLF r _ ^ listSing | iTree | snd | nonemptyFoldl forceMerge _
           | pushAll (pos, I r NIL NONE) fs

= (layout frags)
: f@[pos frag] fs < listCase frags NIL
: r _             < getWolf frag (fTree frag :: layout fs)
^ listSing | iTree | snd | nonemptyFoldl forceMerge _
| pushAll (pos, I r NIL NONE) fs

# simpledata BlockBuffer
- WOODS
- TEXTY lines/(List | List Lexeme) depth/Nat
- BLOCK lines/(List | List Lexeme) depth/Nat prevDepth/Nat

# simpledata LineCat
- CVOID
- CNOTE offset/Nat
- COPEN indent/Nat offset/Nat
- CQUOT offset/Nat
- CSING offset/Nat

# struct BlockState | BS bsPath/Str bsLine/Nat bsBuf/BlockBuffer

= (lineCat lexemes)
: SPAN[_ lOff lEnd x] ls < listCase lexemes CVOID
# simplecase x (CSING lOff)
- LTERM   | CVOID
- LSEMI   | CNOTE lOff
- LLINE _ | CQUOT lOff
- LWYTE   | lineCat ls
- LRUNE   : SPAN[_ _ _ yTok] ys < listCase ls (CSING lOff)
          | If lexiIsSpace-yTok (COPEN Dec-lEnd lOff)
          | CSING lOff

= (blockStep bs@BS[fn lno st] mInp)
    @ eofCase  | (BS fn lno WOODS, (Neq WOODS st && listSing (listRev fst-st)))
    : l        < maybeCase mInp eofCase
    @ lc       | lineCat l
    @ ok       | (buf out)&(BS fn (Inc lno) buf, out)
    @ break    & ls @ (st2, out) (blockStep (BS fn lno WOODS) mInp)
                    | (st2, (listRev ls :: out))

    @ (bd, ad) # simplecase lc (###{bad LineCat} lc)
               - CVOID     | [0 0]
               - CNOTE o   | [o o]
               - COPEN i o | [i o]
               - CQUOT o   | [o o]
               - CSING o   | [o o]

    # simplecase st (###{bad block buffer} st)

    - WOODS
        # simplecase lc (###{bad LineCat} lc)
        - CVOID     | ok WOODS NIL
        - CNOTE _   | ok WOODS NIL
        - COPEN _ _ | ok (BLOCK listSing-l bd Inc-ad) NIL
        - CQUOT _   | ok (TEXTY listSing-l bd) NIL
        - CSING _   | ok WOODS (listSing (listSing l))

    - TEXTY ls deep
        # simplecase lc (break ls)
        - CQUOT d | If d/=deep break-ls
                  | ok (**TEXTY l::ls deep) NIL

    - BLOCK ls deep prev
        | If (CVOID == lc)
            | Ifz prev (break ls)
            | ok (BLOCK ls deep 0) NIL
         | If (Eqz prev && Eqz ad)
             | break ls
         | If (Lth bd deep) (break ls)
         | ok (BLOCK (l::ls) deep (Inc ad)) NIL

= (treeStep st@BS[fil num _] mInp)
@ er@(st2, out)
    | blockStep st
    | fmapMaybe mInp (byt & lexLine (**LN fil num byt))
@ treeOut
    : blockLines < listForEach out
    @ blockLexes (listCat blockLines)
    @ [SPAN[LN[_ firstLineNumber _] _ _ _] _] blockLexes
   ++ firstLineNumber
   ++ ^ layout | listMap clumpFrag | listFromRow | clump _
      | multiLine | listCat blockLines
| (st2, treeOut)

# simpledata (SubLayout a)
- SEQUE (List a)
- PREFX Str (List (Frag a))
- INFIX (NonEmpty a) Str (SubLayout a)

= (lambs fs)
: f more < listCase fs (NONE, NIL)
# simplecase f 0
- LAMB x   | pairMap (CONS x) (lambs more)
- WOLF r _ | (SOME [r more], NIL)

= (subLayout frags)
: f fs < listCase frags (SEQUE NIL)
# simplecase f 0
- WOLF r _ | PREFX r fs
- LAMB x   @ [rest hed] (lambs fs)
           : (ryn, more) < maybeCase rest (SEQUE x::hed)
           | INFIX [x hed] ryn (subLayout more)

= (spanQuotedStr span)
@ txt (spanTxt span)
| If (ByteIx 0 txt == "}") | ByteSlice 2 (Sub (ByteSz txt) 3) txt
| else                     | ByteSlice 1 (Sub (ByteSz txt) 2) txt

= (lineRex acc spans)
: span spans < listCase spans acc
@ txt | ByteDrop 2 | spanTxt span
| lineRex (LINE txt acc) spans

= (onlyLambs clumps)
^ foldl _ 0 clumps
& (acc clump)
# simplecase (snd | clumpFrag clump) 0
- LAMB x   | acc x
- WOLF _ _ | acc

= (paraSeq clumpRex all@[c cs])
| If (all/=NIL && cs==NIL) clumpRex-c
^ NEST {|} _ 0
| Fill 0 (listMap clumpRex all)

(mkInfix rune acc)=(INFX rune (FillR 0 acc) NONE)

= (paraPrefix clumpRex rune frags)
^ _ rune NIL frags
? (go rune acc frags)
: f fs < listCase frags (NEST rune (FillR 0 acc) NONE)
# simplecase f 0
- LAMB cl   | go rune (clumpRex cl  :: acc) fs
- WOLF rx _ | go rune (go rx NIL fs :: acc) NIL

= (paraInfix parenPolicy clumpRex rune initial slay)
^ _ rune listSing-initial slay
? (go rune acc slay)
# simplecase slay 0
- SEQUE _       | mkInfix rune (parenPolicy clumpRex slay :: acc)
- PREFX r xs    | mkInfix rune (paraPrefix clumpRex r xs :: acc)
- INFIX es r xs @ rx (paraSeq clumpRex es)
                | If r==rune | go rune rx::acc xs
                | else       | go r listSing-(mkInfix rune rx::acc) xs

= (parenPolicy clumpRex slay)
# simplecase slay 0
- SEQUE xs      | paraSeq clumpRex xs
- PREFX r xs    | paraPrefix clumpRex r xs
- INFIX es r xs | paraInfix parenPolicy clumpRex r (paraSeq clumpRex es) xs

= (elemRex clumpRex e@SPAN[ln off end l])
# simplecase l (##{elemRex case not handled challenge (impossible)} l)
- LWORD    | WORD (spanTxt e) 0
- LFAIL    | elemRex clumpRex (**SPAN ln off end LRUNE)
- LRUNE    | NEST (spanTxt e) [] 0
- LTEXT    | TEXT (spanQuotedStr e) 0
- LLINE ts | lineRex 0 (listSnoc ts e)
- LNEST brack xs | If brack (NEST {,} (Map clumpRex | onlyLambs xs) 0)
                 ^ parenPolicy clumpRex (subLayout _)
                 | listMap x&(snd | clumpFrag x) (listFromRow xs)

= (rexAddHeir rex c)
@ heir (rexHeir rex)
| rexSetHeir (Ifz heir c | rexAddHeir heir c) rex

= (heirSeq clumpRex wut@[x xs])
| listFoldl rexAddHeir (elemRex clumpRex x)
| listMap (elemRex clumpRex) xs

(ifix rune acc)=(**SHUT rune (FillR 0 acc) NONE)

= (eatInfix clumpRex tightPolicy rune acc slay)
# simplecase slay 0
- SEQUE _       | ifix rune (tightPolicy clumpRex slay :: acc)
- PREFX _ _     | Die {impossible: double tight rune}
- INFIX es r xs ^ eatInfix clumpRex tightPolicy r _ xs
                | If r==rune | (heirSeq clumpRex es :: acc)
                | listSing | ifix rune (heirSeq clumpRex es :: acc)

= (tightPolicy clumpRex slay)
# simplecase slay 0
- SEQUE xs      | heirSeq clumpRex xs
- PREFX r xs    | Ifz xs (NEST r [] 0)
                | PREF r [tightPolicy-clumpRex-(subLayout xs)] 0
- INFIX es r xs | eatInfix clumpRex tightPolicy r (heirSeq clumpRex es)::NIL xs

= (clumpRex clump@SPAN[_ _ _ elems])
| tightPolicy clumpRex | subLayout | listMap spanFrag | listFromRow elems

= (treeRex t)
# simplecase t 0
- TLEAF c     | clumpRex c
- TNODE r s h | OPEN r (Map treeRex s) (maybeCase h 0 x&(treeRex x))

= (treesRex trees)
: t ts < listCase trees (Die {treesRex: empty block})
| If (ts == NIL) | treeRex t
| else           | treeRex (**TNODE {|} (Fill 0 trees) NONE)

= (rexStep bs mInp)
@ (bs, trees) | treeStep bs mInp
@ rexes       | listForEach trees [lino trees]&(lino, treesRex trees)
| (bs, rexes)

# struct Lam
| LAM lamPin/Bit lamMark/Bit lamRecr/Bit lamTag/Nat lamArgs/Nat lamBody/Sire

# simpledata Sire
- V Nat
- K Any
- G Bind
- A Sire Sire
- L Sire Sire
- R (Row Sire) Sire
- M Sire
- F Lam

# struct Bind
| BIND bindKey/Nat     bindValue/Any bindCode/Sire
       bindLocation/Any bindName/Any bindProps/Any

# struct Arg (ARG argDepth/Nat argExp/Sire)

# struct Pot
| POT potLam/Lam potMark/Bool potDeep/Nat potNeed/Nat potArgs/(List Arg)

# struct Res (RES resExp/Sire resPot/(Maybe Pot))

= apple       | foldl A
= appList     | listFoldl A
= (apple_ xs) | foldl A fst-xs (Drop 1 xs)

= (hasRefTo d exp)
# simplecase exp FALSE
- V v   | v==d
- A f x | (hasRefTo d f || hasRefTo d x)
- L v b | (hasRefTo d v || hasRefTo Inc-d b)
- R v b | listAny (hasRefTo (Add d Sz-v)) (b :: listFromRow v)
- M f   | hasRefTo d f
- F l   | hasRefTo Inc-(Add d lamArgs-l) lamBody-l

= (moveTo from to alreadyBound topExp)
^ If from==to topExp (_ alreadyBound topExp)
? (go l e)
# simplecase e e
- V v   | If (Lth v l) e (V | Sub (Add v to) from)
- M x   | M (go l x)
- A f x | A (go l f) (go l x)
- L v b | L (go l v) (go Inc-l b)
- R v b | (ll @ Add l Sz-v)(R (Map (go ll) v) (go ll b))
- F fn  | F (lamBodySet (go _ lamBody-fn) fn)^(Inc | Add l lamArgs-fn)

= (renum d !n args)
: a@ARG[ad ax] as < listCase args NIL
| (moveTo ad (Add d n) 0 ax :: renum d Inc-n as)

= (expandPot d e@POT[lam _ deep _ args])
@ body | moveTo deep d (Inc lamArgs-lam) lamBody-lam
| listFoldr L body
| renum d 0 (ARG d (K 0) :: listRev args)

= (reApp inline d s args f@RES[!fx !me])
@ otherwise
    : r@[rd rx] rs < listCase args f
    | reApp inline d s rs
    | RES (A fx | moveTo rd d 0 rx)
    : e@[_ _mark _ pNeed pArgs] < maybeCase me NONE
    | Ifz pNeed NONE
    | SOME | potNeedSet-(Dec pNeed) | potArgsSet-(r :: pArgs) e
: e < maybeCase me otherwise
| Ifz (potNeed e == 0)&&(potMark e) otherwise
| inline d s args (expandPot d e)

= (inline d s params syr)
@ rap (reApp inline d s params)
# simplecase syr (###{inline: bad sire} syr)
- K _ | rap | RES syr NONE
- V v | rap | RES syr | listIdx v s
- G p | rap | RES syr | resPot | inline d NIL NIL | bindCode PinItem-p
- M b
    @ RES[r me] | inline d s NIL b
    | rap | RES r (fmapMaybe me | potMarkSet TRUE)
- F lam
    @ LAM[_ lMark lRecr _ lArgs lBody] lam
    | rap
    | RES @ s | listWeld (listRep NONE Inc-lArgs) s
          @ d | Inc (Add lArgs d)
          | F | (lamBodySet _ lam)^(resExp | inline d s NIL lBody)
    | If lRecr NONE
    | SOME (POT lam lMark d lArgs NIL)
- R vs b
    @ nBinds (Sz vs)
    @ d_ | Add d nBinds
    @ s_ | listWeld (listRep NONE nBinds) s
    @ vr | Map (inline d_ s_ NIL) vs
    @ br | inline d_ s_ params b
    | RES (R (Map resExp vr) resExp-br) NONE
- L v b
    @ RES[vrs vre]  | inline d     s        NIL    v
    @ RES[brs _bre] | inline Inc-d (vre::s) params b
    | RES (L vrs brs) NONE
- A f x
    @ RES[x _] | inline d s NIL x
    | inline d s (ARG d x :: params) f

# simpledata Exp
- VAL Any
- VAR Nat
- APP Exp Exp

# struct Fun
| FUN funPin/Bool funTag/Nat funSlf/Nat funArg/(List Nat) funBin/(Tab Nat Exp)
      funBod/Exp

= (constantApp f x) | (({VAL}==(Hd f) && {VAL}==(Hd x)) && Neq 1 (Arity fst-f))
= (foldingApp f x)  | If (constantApp f x) VAL-(fst-f fst-x) (APP f x)

= (ingestAst compile s x st@[env nex])
    @ go (ingestAst compile)

    # simplecase x (###{ingestAst: bad input} x)
    - V i   | st,(listIdx i s)
    - M x   | go s x st
    - G g   | st,(VAL (**bindValue | PinItem g))
    - K x   | st,(VAL x)
    - A f x @ [st f] (go s f st)
            @ [st x] (go s x st)
            | st,(foldingApp f x)

    - L v b
        @ [[env nex] vr] | go s v [env nex]
        | If (Hd vr == {APP})
            @ k   | nex
            @ nex | Inc nex
            @ env | bstPut env k vr
            | go (VAR k :: s) b [env nex]
        | go (vr::s) b [env nex]

    - R vs b
        @ nBinds | Sz vs
        @ ks     | Gen nBinds Add-nex
        @ nex    | Add nex nBinds
        @ ss     | listWeld (listFromRow | Map VAR ks) s
        @ st     ^ foldl _ [env nex] (Zip vs ks)
                 & (st [vx k])
                 @ [[env nex] vr] (go ss vx st)
                 | [(bstPut env k vr) nex]
        | go ss b st

    - F lam
        @ LAM[pin _mark _rec tag lArg lBod] lam
        @ slf           | nex
        @ !nex          | Inc nex
        @ arg           | listGen lArg (Add nex)
        @ !nex          | Add nex lArg
        @ s2            | listWeld (listMap VAR listRev-arg) (VAR slf :: s)
        @ [bin nex],bod | go s2 lBod [bstEmpty nex]
        @ [cns free]    | compile nex (FUN pin tag slf arg bin bod)
        ^ [[env nex] _]
        | listFoldl APP (VAL cns) (listMap VAR free)

= (analyzeFn fun@FUN[_ _ fSlf fArg fBin fBod])
^ @ final@[seen tab lis] (_ fBod (bstEmpty, bstEmpty, NIL))
  | (tab, listRev lis)
? (go sx st0@[seen0 tab0 lis0])
# simplecase sx (###{analyzeFn: bad input} sx)
- VAL _   | st0
- APP f x | go x (go f st0)
- VAR k   @ [seen tab lis]
              | If (bstHas k seen0 || Not (bstHas k fBin)) st0
              | go (bstIdx k fBin)
              | (bstIns k k seen0, tab0, lis0)
         ++ seen
         ++ bstIns k Inc-(bstIdx k tab) tab
         ++ If (bstHas k tab) lis k::lis

= (isCodeShaped depth v)
@ h  | Car v
@ hh | Car h
|| (IsNat v && Lth v depth)
&& (IsApp v)
|| Eqz-h
&& (IsApp h)
|| Eq1-hh
 | Eqz-hh

= (codeGen fn stat@(refcounts, refSeq))
@ FUN[fPin fTag fSlf fArg fBin fBod] fn
@ keep
    & k
    : _  < maybeCase (bstSearch k fBin)      FALSE
    : cv < maybeCase (bstSearch k refcounts) FALSE
    | Gth cv 1
@ binds   | listFilter keep refSeq
@ nBind   | listLen binds
@ nArg    | listLen fArg
@ scopeSz | Inc (Add nArg nBind)
@ scope   | (fSlf :: listWeld fArg binds)
@ table   | bstFromPairsList (listZip scope | listEnumFrom 0)
@ cgen
    ? (cgen s)
    # simplecase s (###{codeGen: bad sire} s)
    - VAL k   | If (isCodeShaped scopeSz k) (0 k) k
    - APP f x | 0 (cgen f) (cgen x)
    - VAR v   @ fall (bstIdx v table)
              | If (1 /= bstIdx v refcounts) fall
              : bx < maybeCase (bstSearch v fBin) fall
              | cgen bx
^ If fPin (Pin _) _
^ Law fTag nArg (listFoldr _ cgen-fBod binds)
& (k rest)
| 1 (cgen | bstIdx k fBin) rest

= (compile nex f1)
@ FUN[pin1 tag1 slf1 arg1 bin1 bod1] f1
@ isFree            | k&(Not (k==slf1 || (bstHas k bin1 || listHas k arg1)))
@ stat1@(_, !refs1) | analyzeFn f1
@ free              | listFilter isFree refs1
@ newSelf           | listFoldl APP VAR-nex (listMap VAR free)
@ f2                | funSlfSet | nex
                    | funArgSet | listWeld free arg1
                    | funBinSet | bstIns slf1 newSelf bin1
                    | f1
@ (f3, stat3)       | If Eqz-free (f1, stat1) (f2, analyzeFn f2)
| (codeGen f3 stat3, free)

= (compileSire inlined)
^ (fst _) 0
@ res@([bin n], bod) (ingestAst compile NIL inlined (bstEmpty, 0))
| compile (Add 2 n)
| FUN 0 0 n (listSing (Inc n)) bin bod

(evalSire sire)=(| compileSire | resExp | inline 0 NIL NIL sire)

# struct SireState
| SIRE_STATE
  sireNextKey/Nat sireContext/Str sireScope/Scope sireModules/Modules
  sireLineNum/Nat sireBlock/Rex

# simpledata Leaf
- DECI Nat
- IDNT Str
- CORD Str

= (tryReadLeaf rex)
: _ style _ txt _ _ _ heir _ _ < rexOpen rex
| And Eqz-heir
| If style=={TEXT} | SOME (CORD txt)
| And style=={WORD}
| And txt
| Ifz isDigit-(ByteIx 0 txt) (SOME IDNT-txt)
| And isSireDecimal-txt
| SOME (DECI loadSireDecimal-txt)

(tryReadKey rex)=(fmapMaybe (tryReadLeaf rex) fst)

= (resolveUnqualified rex env sym ss)
@ notFound
    : bn < bstSearchCase sym sireScope-ss (sireErr ss rex {undefined reference})
    | (ss, G bn)
: ng < listFindIndex Eql-(SOME sym) env notFound
| (ss, V ng)

= (intersperse sep xs)
: i < Gen Dec-(Mul Sz-xs 2)
| If (Mod i 2) sep (Ix (Div i 2) xs)

= (lookupVal sym ss)
@ bind (bstIdx sym | sireScope ss)
| And bind
| Ifz (IsPin bind)  | Die {bad bind!},bind
| SOME (**bindValue | PinItem bind)

= (loadMulti acc rex) | Ifz rex acc | loadMulti (acc rexText-rex) rexHeir-rex
= (readMultiLine rex) | strCat | intersperse newlineChar | loadMulti 0 rex

= (readAppExpr readExpr env rex ss)
@ (ss, params) | mapState (readExpr env) (rexKids rex) ss
^ (ss, _)
| Br (Sz params) (K 0, fst params) (apple_ params)

= (sireReadKey ss rex)
| maybeCase (tryReadLeaf rex) (sireErr ss rex {invalid key}) v&(fst v)

= (resolveQualified rex modu name ss)
@ modules  | **sireModules ss
: pScope   < bstSearchCase modu modules (sireErr ss rex {undefined module})
@ scope    | PinItem pScope
: _ix bind < dictSearchCase name scope (sireErr ss rex {undefined symbol})
| (ss, G bind)

= (readRefr _readExpr env rex ss)
@ kids     | rexKids rex
@ rune     | rexRune rex
@ nKid     | Sz kids
| If (nKid == 1)
    @ n | sireReadKey ss fst-kids
    | resolveUnqualified rex env n ss
| If (nKid == 2)
    @ m | sireReadKey ss fst-kids
    @ n | sireReadKey ss snd-kids
    | resolveQualified rex m n ss
| sireErr ss rex {malformed reference}

= (readLin readExpr env rex ss)
@ rune (rexRune rex)
@ kids (rexKids rex)
| If (Sz kids /= 1) | sireErr ss rex {only one param was expected}
@ [ss exp] | readExpr env fst-kids ss
| (ss, M exp)

= (readLet readExpr env rex ss)
@ kids@[nRex vRex bRex] (rexKids rex)
| If (Sz-kids /= 3) | sireErr ss rex {expected three params}
@ [ss v] | readExpr env vRex ss
@ [ss b] | readExpr (SOME (sireReadKey ss nRex) :: env) bRex ss
| (ss, L v b)

= (readLetRecBinds acc rex ss ok)
| Ifz rex (ok ss | FillR 0 acc)
@ kids | rexKids rex
@ nKid | Sz kids
| Ifz (nKid==2 || nKid==3) | sireErr ss rex {invalid bind}
@ [keyRex valRex moreRex] kids
@ n | sireReadKey ss keyRex
| readLetRecBinds ([n valRex] :: acc) moreRex ss ok

= (readLetRec readExpr env rex ss)
@ kids@[vRex bRex moreRex] (rexKids rex)
| If (Sz kids /= 2)        | sireErr ss rex {expected two params}
| If (rexRune vRex /= {=}) | sireErr ss rex {binder must be an (=) rune}
: ss binds   < readLetRecBinds NIL vRex ss
@ names      | Map fst binds
@ varRexes   | Map snd binds
@ subenv     | listWeld (listFromRow | Map SOME names) env
@ [ss binds] | mapState readExpr-subenv varRexes ss
@ [ss body ] | readExpr subenv bRex ss
| (ss, R binds body)

= (readKet readExpr env rex ss)
@ kids            | rexKids rex
@ nKid            | Sz kids
@ last            | get kids Dec-nKid
| If (Lth nKid 2) | sireErr ss rex {expected at least two params}
@ [ss v] | readExpr env last ss
@ [ss b] | mapState readExpr-(SOME {_} :: env) (Take Dec-nKid kids) ss
| (ss, L v (apple_ b))

= (readAnonSig rex ss)
| If rexIsLeaf-rex        | [(sireReadKey ss rex)]
| If (rexRune rex /= {|}) | sireErr ss rex {invalid lambda signature}
| Map sireReadKey-ss rexKids-rex

= (readAnonLam readExpr env rex ss)
@ kids | rexKids rex
@ nKid | Sz kids
| If (nKid /= 2)  | sireErr ss rex {expected two params}
@ [sigRex bodRex] | kids
@ argNames        | readAnonSig sigRex ss
@ [ss body]       ^ readExpr _ bodRex ss
                  ^ listWeld _ env
                  | listRev (NONE :: listFromRow (Map SOME argNames))
| (ss, F (LAM FALSE FALSE FALSE 0 Sz-argNames body))

= (readFuncHead rex ss)
| If (rexRune rex == {**})
    @ kids@[keyRex] (rexKids rex)
    | If (Sz kids /= 1)
        | sireErr ss rex {invalid lambda name}
    | (TRUE, sireReadKey ss keyRex)
| (FALSE, sireReadKey ss rex)

= (readWutSig rex ss)
| If rexIsLeaf-rex (ss, (FALSE, sireReadKey ss rex, []))
@ kids | rexKids rex
| If ((rexRune rex /= {|}) || Null kids)
    | sireErr ss rex {invalid lambda signature}
@ [inl nam] | readFuncHead fst-kids ss
| (ss, (inl, nam, Map sireReadKey-ss (Drop 1 kids)))

= (mkF pin mark tag numArgs body)
@ isRecur (hasRefTo numArgs body)
| F (LAM pin mark isRecur tag numArgs body)

= (readLam pinned readExpr env rex ss)
@ kids@[sigRex bodRex] | rexKids rex
@ nKid                 | Sz kids
| If (nKid /= 2)       | sireErr ss rex {expected two or three params}
@ [ss res@[inline f argNames]] | readWutSig sigRex ss
@ env2 ^ listWeld _ env
       | listRev | listMap SOME (f :: listFromRow argNames)
@ nArg | Sz argNames
@ [ss body] | readExpr env2 bodRex ss
| (ss, mkF pinned inline f nArg body)
| else

= (readPrimLeaf readExpr blockRex env rex ss)
@ heir      | rexHeir rex
@ invalid   | sireErr ss rex {malformed leaf}
@ ifNotLeaf | If (rexStyle rex /= {WORD}) invalid
            : macro   < maybeCase (lookupVal {#} ss) invalid
            @ [ss ex] | macro ss (PREF {#} [rex] 0)
            | readExpr env ex ss
| If heir   | readExpr env (OPEN {#} (rexSetHeir 0 rex, heir) 0) ss
: leaf      < maybeCase (tryReadLeaf rex) ifNotLeaf
# simplecase leaf (sireErr ss leaf {readPrimLeaf: bad leaf})
- DECI n | (ss, K n)
- CORD c | (ss, K c)
- IDNT n | resolveUnqualified blockRex env n ss

= (readPinned _readExpr _env rex ss)
@ sons (rexSons rex)
| Ifz (Eq1 Sz-sons && Eqz rexHeir-rex) | sireErr ss rex {usage: ##3, ##foo}
| (ss, K Pin-(sireReadKey ss fst-sons))

= (readPrimExpr readExpr env rex ss)
: type style rune _ _ _ _ _ _ _ < rexOpen rex
# simpleswitch type (Die "impossible")
- {EMBD}
    | (ss, K rexEmbd-rex)
- {LEAF}
    | If (style == {LINE}) | (ss, K readMultiLine-rex)
    | readPrimLeaf readExpr rex env rex ss
- {NODE}
    ^ _ readExpr env rex ss
    # simpleswitch rune (sireErr ss rex {undefined rune})
    - {|}   | readAppExpr
    - {#|}  | readAppExpr
    - {-}   | readAppExpr
    - {#-}  | readAppExpr
    - {**}  | readLin
    - {#**} | readLin
    - {@}   | readLet
    - {#@}  | readLet
    - {@@}  | readLetRec
    - {#@@} | readLetRec
    - {^}   | readKet
    - {#^}  | readKet
    - {&}   | readAnonLam
    - {#&}  | readAnonLam
    - {?}   | readLam FALSE
    - {#?}  | readLam FALSE
    - {??}  | readLam TRUE
    - {#??} | readLam TRUE
    - {.}   | readRefr
    - {#.}  | readRefr
    - {##}  | readPinned
    - {###} | readPinned

= (readExpr e rex ss)
@ noMacro           | readPrimExpr readExpr e rex ss
| Ifz rexIsNode-rex | noMacro
: macro             < maybeCase (lookupVal rexRune-rex ss) noMacro
@ [ss expo]         | macro ss rex
| readExpr e expo ss

(evalExpr rex st0)=(pairMap evalSire | readExpr NIL rex st0)

= (isExpRune rune)
| Has rune , {|} {#|} {-} {#-} {**} {#**} {@} {#@} {@@} {#@@} {^} {#^}
             {&} {#&} {?} {#?} {??} {#??} {.} {#.} {##} {###}

= (execBind rx (nm, expr) ss@SIRE_STATE[nex ctx scope modules lino blk])
@ !val | Force (evalSire expr)
@ !pin | Pin (BIND nex val expr ctx nm 0)
@ !nex | Inc nex
@ !ss  | SIRE_STATE nex ctx (bstPut scope nm pin) modules lino blk
| Trace nm (ss, val)

= (readLawBinder ss sigRex)
@ kids@[hedRex] (rexKids sigRex)
@ hedKids    (rexKids hedRex)
@ hedRune (rexRune hedRex)
| If (Null kids || (rexRune sigRex /= {|})) | sireErr ss sigRex {bad law sig}
^ (_, Map sireReadKey-ss (Drop 1 kids))
| If hedRune/={**} (FALSE, sireReadKey ss hedRex)
| Ifz (Eq1 | Sz-hedKids) | sireErr ss sigRex {bad binder}
| (TRUE, sireReadKey ss (fst hedKids))

= (readBindBody bb rex ss)
@ left  & _               | NIL
@ right & [[_ self] args] | listRev | listMap SOME (self :: listFromRow args)
| readExpr (eitherCase bb left right) rex ss

= (readBindCmd ss rex rexes@[sg exprRex])
| Ifz (Eq2 Sz-rexes) | sireErr ss rex {expected two or three params}
@ binder             | maybeCase tryReadKey-sg RIGHT-(readLawBinder ss sg) LEFT
@ [ss expr]          | readBindBody binder exprRex ss
^ (ss, eitherCase binder v&(v, expr) _)
& [[doInline tagName] argNames]
| (tagName, mkF TRUE doInline tagName Sz-argNames expr)

= (doDefine acc rex ss)
@ heir (rexHeir rex)
| If (rexRune rex == rexRune heir)
    @ [ss tb] | readBindCmd ss rex (rexSons rex)
    @ [ss v1] | execBind rex tb ss
    | doDefine (Snoc acc v1) heir ss
@ [ss tb] | readBindCmd ss rex rexKids-rex
@ [ss v1] | execBind rex tb ss
| (ss, Snoc acc v1)

= (switchToContext newCtx SIRE_STATE[nex oldCtx scope oldMods lino block])
^ SIRE_STATE nex newCtx bstEmpty _ 1 block
| Ifz oldCtx oldMods
| bstPut oldMods oldCtx Pin-(bstSave scope)

= (doEnter topRex ss)
@ kids | rexKids topRex
@ nKid | Sz kids
@ dead | sireErr ss topRex {malformed module header}
| If Eq1-nKid
    @ [targetRex] | kids
    @ target      | sireReadKey ss targetRex
    | Ifz (sireContext ss || bstIsEmpty (sireScope ss))
        | sireErr ss topRex {broken pre-condition}
    | (switchToContext target ss, 0)
| If Eq2-nKid
    @ [targetRex beforeForm] kids
    @ beforeSons (rexSons beforeForm)
    | If || (rexRune beforeForm /= {<-})
         || (rexHeir beforeForm /= 0)
          | (Sz beforeSons /= 1)
      dead
    @ target    | sireReadKey ss targetRex
    @ wasJustAt | sireReadKey ss fst-beforeSons
    | If (sireContext ss /= wasJustAt)
        | sireErr ss topRex {broken pre-condition}
    | (switchToContext target ss, 0)
| dead

= (fmtAssert x y)
^ OPEN "=?=" [_] 0
| OPEN "*" [x]
| OPEN "*" [y]
| 0

= (doAssert rex ss)
@ kids@[xr yr]      | rexKids rex
| If (Sz kids /= 2) | sireErr ss rex {#=?= requires two parameters}
@ [ss xe]           | readExpr NIL xr ss
@ [ss ye]           | readExpr NIL yr ss
@ xv                | evalSire xe
@ yv                | evalSire ye
| Trace (fmtAssert xr yr)
| If xv==yv (ss, xv)
| Trace (fmtAssert EMBD-xv EMBD-yv)
| sireErr ss rex {assertion failed}

= (doMultiAssert rex ss)
@ ryn (rexRune rex)
^ _ NIL rex ss
? (go acc rex ss)
@ heir (rexHeir rex)
| If (Eqz heir || (rexRune heir /= ryn))
    @ [ss val] | doAssert rex ss
    | (ss, FillR 0 val::acc)
@ [ss val] | doAssert (rexSetHeir 0 rex) ss
| go val::acc heir ss

= (doFilter ryn acc rex ss)
| Ifz rex ^ (sireScopeSet (bstFromPairsList _) ss, 0)
          : k < listForEach acc
          : v < bstSearchCase k (**sireScope ss) | sireErr ss varE-k {undefined}
          | [k v]
| If (rexRune rex /= ryn) | sireErr ss rex {bad export-filter syntax}
@ syms | Map sireReadKey-ss rexSons-rex
@ acc  | listWeld (listFromRow syms) acc
| doFilter ryn acc (rexHeir rex) ss

= (importModule rex modu mWhite ss)
@ otherScope
    : modPin < bstSearchCase modu sireModules-ss
                 (sireErr ss rex {undefined module})
    | If IsPin-modPin (PinItem modPin)
    | sireErr ss rex {corrupted sire state; module is not a pin}
@ oldScope (sireScope ss)
^ sireScopeSet _ ss
: whitelist < maybeCase mWhite (bstUnion (bstLoad otherScope) oldScope)
| foldl (acc kv & bstPut acc fst-kv snd-kv) oldScope
: k < foreach whitelist
| dictSearchCase k otherScope (sireErr ss (TEXT k 0) {undefined symbol})
      (_ bind & [k bind])

= (doImport ryn blockRex ss)
^ _ ss blockRex
? (go ss rex)
| Ifz rex (ss, 0)
@ bad  | sireErr ss rex {bad import}
@ sons | rexSons rex
@ nSon | Sz sons
| If (rexRune rex /= ryn) bad
| If (nSon == 1)
    @ [moduleRex] | sons
    @ modu | sireReadKey ss moduleRex
    @ ss   | importModule blockRex modu NONE ss
    | go ss (rexHeir rex)
| If (nSon == 2)
    @ [moduleRex ilist] sons
    @ modu | sireReadKey ss moduleRex
    @ syms | Ifz (Eql {,} rexRune-ilist && Eqz rexHeir-ilist) bad
           | Map sireReadKey-ss rexSons-ilist
    @ ss   | importModule blockRex modu SOME-syms ss
    | go ss (rexHeir rex)
| bad

= (executeSire rex ss)
@ rune     | rexRune rex
@ doMulti  | (rex ss)&(mapState executeSire rexKids-rex ss)
@ noMacro
    ^ _ rex ss
    | Ifz rexIsNode-rex evalExpr
    # simpleswitch rune | If isExpRune-rune evalExpr
                        | sireErr ss rex {undefined rune}
    - {#=}   | doDefine []
    - {=}    | doDefine []
    - {####} | doEnter
    - {*}    | doMulti
    - {#*}   | doMulti
    - {^-^}  | doFilter rune NIL
    - {#^-^} | doFilter rune NIL
    - {=?=}  | doMultiAssert
    - {#=?=} | doMultiAssert
    - {#:|}  | doImport rune
    - {:|}   | doImport rune
: macro     < maybeCase (lookupVal rune ss) noMacro
@ [ss expo]  | macro ss rex
| executeSire expo ss

= (consumeLines buf)
@ wid (ByteSz buf)
^ _ 0 0
? (go acc off)
@ ix (strElemIndexOff newlineChar off buf)
| If ix==wid | (acc, ByteDrop off buf)
@ sliceSz    | Sub ix off
@ acc        | acc (ByteSlice off sliceSz buf)
| go acc Inc-(Add off sliceSz)

= (sireRepl output prevLino ss bs buf rawInput)

    @ eof          | Eqz rawInput
    @ (lines, buf) | consumeLines
                   | strWeld buf (If eof newlineChar rawInput)
    @ lines        | (If eof (Snoc _ NONE) _)^(Map SOME lines)

    @ (bs, blocks)
        ^ _ bs NIL (listFromRow lines)
        ? (go bs acc lines)
        : line lines  < listCase lines (bs, listCat (listRev acc))
        @ (bs, frags) | rexStep bs line
        | go bs (CONS frags acc) lines

    @ [!ss newLino]
        ^ listFoldl _ [ss prevLino] blocks
        & ([ss prevLino] [newLino rex])

        @ newLines   | Sub newLino prevLino
        @ ss         | sireLineNumSet (Add newLines | sireLineNum ss)
                     | sireBlockSet rex
                     | ss
        @ [!ss _out] | executeSire rex ss
        | [ss newLino]

    | Ifz eof (0, sireRepl output newLino ss bs buf)

    : main < maybeCase (lookupVal {main} ss) Die-{main is not bound}
    (output main, {NO MORE INPUT})

= (runSireRepl save)
| sireRepl save 0 (SIRE_STATE 1 0 0 0 0 '()) (BS {REPL} 1 WOODS) ""

main=(runSireRepl _&1)

= (dictHas k t) | dictSearchCase k t 0 (_ _)&1
= (dictGet t k) | dictSearchCase k t 0 (_ v)&v
= (dictKeys d)  | Gen (Div Sz-d 2) i&(get d (Add i i))

= (dictPut d k v)
@ res (searchTab k d)
@ ix  (Div res 2)
| If (Mod res 2) (Up Inc-ix v d)
| Splice ix [k v] d

= (dictFoldl f z d)
^ _ z 0 Sz-d
? (go acc i rem)
| Strict 2 i acc
| Ifz rem acc
@ k (Ix i d)
@ v (Ix Inc-i d)
| go (f acc k v) (Add 2 i) (Sub rem 2)

(dictWeld x y)=(dictFoldl dictPut x y)


;;; Seed Types ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(**ATOM x = x)(**HOLE i = [i])(**CELL f x = [f x])

= (**getCellCase x fallback ok)
| If (Neq 2 Sz-x) fallback
| **ok (fst x) (snd x)


;;; Seed: Dedupe and Shattering Fragments ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

= (**elemIdxCase e row nf f)
@ i (FindEq e row)
| If (Eql i Sz-row) nf
| **f i

; type Node = ATOM Nat | CELL Nat Nat

; type Key = Nat

; intern Any -> (key:Key, KeyMap (Node, Refcount), Map Node Key)

= (intern holes top) ; Array Any > Any > (DedupTable, DedupIndex)
^   @ [tbl seen _key] (_ [] [] top)
    | (tbl, seen)
? (go tbl seen x)
    ; each step returns the key for the given input
| Force
@ [tbl seen node]
    ; '] Every node is either a NAT node, a HOLE node, or a ATOM node.
    ; ']
    ; '] This code does a lookup of that ADT in the `seen` tab, but we
    ; '] don't want to have everything in one table here because that
    ; '] requires noun-equality.
    ; ']
    ; '] We can also hard-code the HOLE logic to only work with #0 and to
    ; '] always create a seed that expects that.
    ^ elemIdxCase x holes _ i&[tbl seen HOLE-i]
    | If IsNat-x [tbl seen ATOM-x]
    @ [tbl seen h] (go tbl seen Car-x)
    @ [tbl seen t] (go tbl seen Cdr-x)
    ; '] Importantly, we need to process subnodes *first*.
    ; ']
    ; '] Can we somehow avoid this recursion using our new RPN framework?
    ; ']
    ; '] With out new setup, we don't *see* a cell until it has been
    ; '] fully processed, so I assume yes?
    ; ']
    ; '] We need a table of seen atoms and a table of seen cells.
    ; ']
    ; '] And then we have a stack of keys.  Whenever we see a `mkapp`, we just
    ; '] pop two things from the stack and that's the cell value.
    ; ']
    ; '] We should combine those two together with (x<<32 | y) and then use
    ; '] that as the key into the "seen cells" table.
    ; ']
    ; '] EZ
    | [tbl seen (CELL h t)]
@ res | **searchTab node seen
@ kix | Div res 2
@ vix | Inc kix
| If (Mod res 2)
    ; '] If we've already seen this, then we bump the refcount.
    ; ']
    ; '] We need the refcounts to all live within a single "namespace", which
    ; '] can, I guess, but a number from a unique supply.
    ; ']
    ; '] Which means that the atoms/cells tables will need to have those unique
    ; '] IDs as values.
    @ key       | Ix vix seen
    @ !refcount | Inc | snd | get tbl key
    @ tbl       | put tbl key [node refcount]
    | Force [tbl seen key]
| else
    ; '] If we have *not* seen this before, then we set the refcount to 1, and
    ; '] we update the seen table to include the value.
    @ key Sz-tbl
    ++ Snoc tbl [node 1]
    ++ Splice kix [node key] seen
    ++ key

= (shatter tbl) ; DedupTable > SortedRow Nat
^ dictKeys (_ 0 Dec-(Sz tbl))
? (go parentRefs key)
@ node,refs (get tbl key)
: h t < getCellCase node []
^ foldl dictWeld (go refs h) (go refs t, _)
| If (Gth refs parentRefs) [key 0] []


;;; Seed: Nat-Table Layout ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

u8max=255
u64max=18446744073709551615

(wordSz n)=(DivCeil (BitSz n) 64)

= (countBigs keys nByt nWrd bigSzs i)
@ n (Ix i keys)
| If (Gte i Sz-keys || Not (IsNat n))
    | (nByt, nWrd, Rev bigSzs)
| else
    | countBigs keys nByt nWrd (bigSzs wordSz-n) Inc-i

= (countWords keys nByt i)
@ nWrd                        | Sub i nByt
| If (Gte i Sz-keys)          | (nByt, nWrd, 0)
| If (Lth u64max | Ix i keys) | countBigs keys nByt nWrd [] i
| else                        | countWords keys nByt Inc-i

= (countBytes keys i)
| If (Gte i Sz-keys)         | (i, 0, 0)
| If (Lth u8max | Ix i keys) | countWords keys i 0
| else                       | countBytes keys Inc-i

;; TODO: Jet {SliceRev : Row a > Nat > Nat > Row a} and use that
;; instead of {Rev | take nAtom nodes}. Generally, we're going to need
;; "Slice" variants of every row operation.

= (countAtoms seen) ; DedupIndex > (Row Nat, Nat, Nat, Nat, Row Nat)
@ keys                   | dictKeys seen
@ (nByt, nWrd, bigSizes) | countBytes keys 0
@ nAtom                  | Add Sz-bigSizes (Add nByt nWrd)
@ atoms                  | Rev (Take nAtom keys)
| Force (atoms, nByt, nWrd, bigSizes)

= (**byteSliceFromW64 n) | (0, 8,        n)
= (**byteSliceFromW8 n)  | (0, 1,        n)
= (**byteSliceFromStr n) | (0, ByteSz n, n)

= (writeHeader nHol bignatSizes nWords nBytes nFrags atoms)
^ | ByteFill | Cat | Force _
++  ++ byteSliceFromW64 nHol
    ++ byteSliceFromW64 (Sz bignatSizes)
    ++ byteSliceFromW64 nWords
    ++ byteSliceFromW64 nBytes
    ++ byteSliceFromW64 nFrags
++ Map [0 8] bignatSizes
++   : x < foreach atoms
     | If (Lte x u8max)  | byteSliceFromW8 x
     | If (Lte x u64max) | byteSliceFromW64 x
     | else              | (0, Mul 8 wordSz-x, x)
++ [257]

(writeRefr refSz ref)=(BitSet Inc-refSz (Mul 2 ref))

= (writeTree frags tbl seen nHoles nAtoms refSz key)
@ [node refcount] (get tbl key)
^ Br Sz-node _ 0
++  ; (ATOM n)
    ^ [(writeRefr refSz _)]
    ^ Add nHoles (Sub nAtoms | Inc _)
    | **dictSearchCase node seen 0 (ix vl & Div ix 2)
++  ; (HOLE n)
    @ n (fst node)
    | [(writeRefr refSz n)]
++  ; (CELL h t)
    @ h (fst node)
    @ t (snd node)
    @ go | writeTree frags tbl seen nHoles nAtoms refSz
    : ix < elemIdxCase key frags (Cat [[3] go-h go-t]) ; 3 = bitstring"1"
    | [(writeRefr refSz (sum [ix nAtoms nHoles]))]

= (writeBody nHoles nAtoms tbl seen frags)
@ write  (writeTree frags tbl seen nHoles nAtoms)
^ BitFill (Snoc (_ 0 Sz-frags) 3)
? (go !i rem)
| Ifz rem []
@ key              | Ix i frags
@ maxRef           | Dec (Add nHoles (Add nAtoms i))
@ refSz            | BitSz maxRef
@ [[h t] refcount] | get tbl key
| Cat (write refSz h, write refSz t, go Inc-i Dec-rem)

= (save holes val)
@ tbl,seen                       | Force (intern holes val)
@ !frags                         | Force (shatter tbl)
@ !nFrags                        | Sz frags
@ (!nats, !nByt, !nWrd, !bigSzs) | countAtoms seen
@ !nBig                          | Sz bigSzs
@ !nHol                          | Sz holes
@ !nNat                          | Sz nats
@ !headNat                       | writeHeader nHol bigSzs nWrd nByt nFrags nats
@ !bodyNat                       | writeBody nHol nNat tbl seen frags
@ !headBitSz                     | PadLen headNat
@ !bodyBitSz                     | BitSz bodyNat
@ !headByteSz                    | Div headBitSz 8
@ !bodyByteSz                    | DivCeil bodyBitSz 8
| ByteFill
++ (0, headByteSz, headNat)
++ (0, bodyBitSz, bodyNat)

= (loadHeader seedNat)
@ nHol | ByteSlice 0  8 seedNat
@ nBig | ByteSlice 8  8 seedNat
@ nWrd | ByteSlice 16 8 seedNat
@ nByt | ByteSlice 24 8 seedNat
@ nFrg | ByteSlice 32 8 seedNat
^ _ NIL 0 40
? (bigSizesLoop acc bigIx off)
| If bigIx/=nBig
    ^ bigSizesLoop (_ :: acc) Inc-bigIx (Add 8 off)
    | ByteSlice off 8 seedNat
@ bigSizes (FillR 0 acc)
^ _ NIL (listFromRow bigSizes) off
? (bigsLoop acc rem off)
| If (rem /= NIL)
    @ [sz rem] | rem
    @ wid      | Mul 8 sz
    @ Nat      | ByteSlice off wid seedNat
    | bigsLoop Nat::acc rem (Add off wid)
^ _ acc 0 off
? (wordsLoop acc i off)
| If (i /= nWrd)
    ^ wordsLoop (_ :: acc) Inc-i (Add 8 off)
    | ByteSlice off 8 seedNat
^ _ acc 0 off
? (bytesLoop acc i off)
| If (i /= nByt)
    ^ bytesLoop (_ :: acc) Inc-i (Add 1 off)
    | ByteSlice off 1 seedNat
@ nats (FillR 0 acc)
| [nHol nFrg nats off]

= (loadTree body table refSz off)
^ _ off
? (go off)
@ section (BitSet Inc-refSz | BitSlice off Inc-refSz body)
@ flag (BitIx off body)
| If flag
    @ off   | Inc off
    @ off,h | go off
    @ off,t | go off
    | [off h-t]
| else
    @ off Inc-off
    @ ref (BitSlice off refSz body)
    | (Add off refSz, get table ref)

= (loadBody body table nFrags)
^ (_ table nFrags 0)
? (go table rem off)
@ maxRef    | Dec (Sz table)
@ refSz     | BitSz maxRef
| Ifz rem   | (off, get table maxRef)
@ load      | loadTree body table refSz
@ [off h]   | load off
@ [off t]   | load off
| go (Snoc table h-t) Dec-rem off

(PadLen Nat)=(Dec BitSz-Nat)

= (load holes seedNat)
@ [nHol nFrg nats off]  | loadHeader seedNat
| If (nHol /= Sz holes) | NONE
@ table                 | Weld holes nats
@ body                  | ByteDrop off seedNat
@ [bitsRead result]     | loadBody body table nFrg
| result

= (PinRefs pin) ; Pin > Row Pin
^ _ PinItem-pin 0
? (go x !seen)
| Ix PlanTag-x
++ If (Has x seen) seen (seen x)
++ go LawBody-x | go ##1 seen
++ go Cdr-x     | go Car-x seen
++ seen

= (HasPin x)
| Ix PlanTag-x
++ 1
++ HasPin LawBody-x
++ Or (HasPin Hd-x) (Any HasPin x)
++ 0

= (SaveGerm pin)      | And IsPin-pin (_, save _ PinItem-pin)^(PinRefs pin)
= (LoadGerm refs bar) | Pin (load refs bar)
= (SaveSeed fan)      | save (If HasPin-fan [##0] []) fan

= (LoadSeed seedNat)
@ [nHol nFrg nats off]   | loadHeader seedNat
@ holes                  | If nHol [##0] []
| If (Gth nHol 1)        | 0
@ table                  | Weld holes nats
@ body                   | ByteDrop off seedNat
@ [bitsRead result]      | loadBody body table nFrg
| result


;;; Quine Main ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

= (seedOutput main)
@ seedNat    | SaveSeed main
@ seedWordSz | DivCeil (BitSz seedNat) 64
@ seedBar    | BitSet (Mul seedWordSz 64) seedNat
seedBar

; main=(runSireRepl seedOutput)
main=(runSireRepl _&1)

=?= (SaveSeed 0)
  546812681195752981093125556779405341338298634825038495787206487391911457466260083161322758290276352

; =?= (intern [##0] ingestAst)
;     (intern [##0] ingestAst)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; data Shape
;     = LEAF Nat            = @
;     | HOLE Int            = [@]
;     | CELL Shape Shape    = [@ @]

= (closureShape planShape o sz)
| Ifz sz (planShape Hd-o)
@ i  | Dec sz
@ tl | planShape (Ix i o)
| (closureShape planShape o i, tl)

= (pinShape planShape item)
| Ifz item [0] ([0], planShape item)

= (appShape planShape o _ _)
| closureShape planShape o Sz-o

= (lawShape planShape n a b)
@ bs planShape-b
| [[[[[0] 1] n] a] bs]

= (planShape o)
@ p pinShape-planShape
@ l lawShape-planShape
@ a appShape-planShape-o
@ z 0
@ m _&o
| ##3 p l a z m o

(planShape 0          =?= 0)
(planShape 5          =?= 5)
(planShape ##0        =?= [0])
(planShape ##1        =?= ([0], 1))
(planShape (x & x)    =?= (((([0], 1), 0), 1), 1))
(planShape (f x ?? 2) =?= ([0], (((([0], 1), "f"), 1), 2)))

= (closureSize !n planSize o sz)
| Ifz sz | planSize n Hd-o
| closureSize (planSize n (Ix Dec-sz o)) planSize o Dec-sz

= (pinSize n planSize item)
| planSize-(Inc n)-item

= (appSize n planSize o _ _)
| closureSize Inc-n planSize o Sz-o

= (lawSize n planSize _ _ b)
| planSize-(Add 5 n)-b

= (planSize !n o)
@ p pinSize-n-planSize
@ l lawSize-n-planSize
@ a appSize-n-planSize-o
@ z (Inc n)
@ m _&(Inc n)
| ##3 p l a z m o

E=0
Z=1
C=2
A=3

; <0> -> H[0]
; <3> -> (<0> 3) -> H[0] A[3] C
; <x> -> (<0> 3) -> [H[0] (ival x ~[C])]
;
; {n a b} -> (| H | A 1 | C | go n | A a | go b
; <3> -> (<0> 3) -> H A[3] C
; <x> -> (<0> 3) -> [H (ival x ~[C])]
;
; 0 _[x y z] -> x C y C z C
;
; f[x y z] -> f x C y C z C

= (ipin ival k item)
| Ifz item Z-k
| Z-(ival item C-k)

= (ilaw ival k n a b)
| Z | A 1 | C | A n | C | A a | C | ival b C-k

= (irow ival o i k)
| If (Gte i Sz-o) k
| ival (Ix i o) C-(irow ival o Inc-i k)

= (iapp ival o k _ _)
| ival Hd-o (irow ival o 0 k)

= (ival o k)
@ p ipin-ival-k
@ l ilaw-ival-k
@ a iapp-ival-o-k
@ z (A o k)
@ m _&((A o k))
| ##3 p l a z m o

(ival 3       E =?= (| A 3 | E))
(ival ##3     E =?= (| Z | A 3 | C | E))
(ival Inc     E =?= (| Z | Z | A 1 | C | A "Inc" | C | A 1 | C | A 0 | Z | A 2 | C | C | A 1 | C | C | C E))
(ival (3 4)   E =?= (| A 3 | A 4 | C | E))
(ival (3 4 5) E =?= (| A 3 | A 4 | C | A 5 | C | E))
(ival x&x     E =?= (| Z | A 1 | C | A 0 | C | A 1 | C | A 1 | C | E))

(cell [x [f more]])=[f-x more]

= (rebuild !stack code)
| Ix Hd-code
++ stack
++ @ [k]   code (rebuild [##0 stack] k)
++ @ [k]   code (rebuild cell-stack  k)
++ @ [n k] code (rebuild [n stack]   k)

( rebuild 0 ival-(##3 1)-E     =?=  [(##3 1) 0]    )
( rebuild 0 ival-(##3)-E       =?=  [##3 0]        )
( rebuild 0 ival-(x&x)-E       =?=  [x&x 0]        )
( rebuild 0 ival-Inc-E         =?=  [Inc 0]        )
( rebuild 0 ival-(I x ?? x)-E  =?=  [(I x ?? x) 0] )

= (count !acc code)
| Ix Hd-code
++ acc
++ @ [k]   code | count acc     k
++ @ [k]   code | count Inc-acc k
++ @ [n k] code | count acc     k

; count 0 ival-Inc-E       =?= 8          )
; count 0 ival-Add-E       =?= 160        )
; count 0 ival-count-E     =?= 3655       )
; count 0 ival-ingestAst-E =?= 122666     )
; count 0 ival-execBind-E  =?= 1073538    )
; count 0 ival-doDefine-E  =?= 14913465   )
; count 0 ival-main-E      =?= 107513473  )

; Native time = 10m15s
; Haskell time = 12m42s

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

= sbEmpty        | 0
= (**sbSing k v) | 1 k v 0 0

sbSize=Hd

= (sb k v l r)
@ sz | Inc (Add sbSize-l sbSize-r)
| sz k v l r

= (**sbOpen x k)
| **k (Hd x) (Ix 0 x) (Ix 1 x) (Ix 2 x) (Ix 3 x)

= (**sbCase x empty node)
| Ifz x empty
| sbOpen x node

L=sbSing
N=sb
E=0

= (singleL key val a right)
: _ koy vol b c < sbOpen right
| sb koy vol (sb key val a b) c

= (singleR key val left c)
: _ koy vol a b < sbOpen left
| sb koy vol a (sb key val b c)

= (doubleL key val a right)
: _ rkey rval son d < sbOpen right
: _ skey sval b   c < sbOpen son
| sb skey sval (sb key val a b) (sb rkey rval c d)

= (doubleR key val left d)
: _ lkey lval a son < sbOpen left
: _ skey sval b c   < sbOpen son
| sb skey sval (sb lkey lval a b) (sb key val c d)

=?= (singleL 7 7 E (L 8 8))
    (N 8 8 L-7-7 E)

=?= (singleR 7 7 (L 6 6) E)
    (N 6 6 E L-7-7)

=?= (singleL 7 7 E (N 8 8 E L-9-9))
    (N 8 8 L-7-7 L-9-9)

=?= (singleL 5 5 E (N 8 8 L-7-7 L-9-9))
    (N 8 8 (N 5 5 E L-7-7) L-9-9)

=?= (doubleL 5 5 E (N 8 8 L-7-7 L-9-9))
    (N 7 7 L-5-5 (N 8 8 E L-9-9))

=?= (doubleR 5 5 (N 2 2 L-1-1 L-3-3) E)
    (N 3 3 (N 2 2 L-1-1 E) L-5-5)

= (rotateL k v l r)
: rz _ _ rl rr < sbOpen r
| If (Lth sbSize-rl (Mul 2 sbSize-rr)) | singleL k v l r
| else                                 | doubleL k v l r

= (rotateR k v l r)
: lz _ _ ll lr < sbOpen l
| If (Lth sbSize-lr (Mul 2 sbSize-ll)) | singleR k v l r
| else                                 | doubleR k v l r

= (balance k v l r)
@ lsz | sbSize l
@ rsz | sbSize r
@ xsz | Inc (Add lsz rsz)
@ top | xsz k v l r
| If (Lte (Add lsz rsz) 1) | top
| If (Gte rsz (Mul 4 lsz)) | rotateL k v l r
| If (Gte lsz (Mul 4 rsz)) | rotateR k v l r
| else                     | top

= (sbInsert key val x)
: xsz xkey xval left right < sbCase x (sbSing key val)
| Ix (Cmp key xkey)
++ balance xkey xval (sbInsert key val left) right
++ xsz key val left right
++ balance xkey xval left (sbInsert key val right)

= (sbSearch key tree)
: _ k v l r < sbCase tree NONE
| Ix (Cmp key k) (sbSearch key l, SOME v, sbSearch key r)

= (stream v)         | foldr 0 NIL v
= (**lcase xs nil cons) | Ifz xs nil (**cons Ix-0-xs Ix-1-xs)

= (fromList l)
^ _ 0 l
? (go !acc l)
: [k v] l < lcase l acc
| go (sbInsert k v acc) l

= (gen n f)
^ _ Nat-n
? (go i)
| And i (go Dec-i | f Dec-i)

(derp n)=(| fromList | stream | gen n x&((xx @ Mul Inc-x 11)(xx, xx)))

(sbSearch 11 derp-0 =?= NONE)
(sbSearch 11 derp-1 =?= SOME-11)
(sbSearch 11 derp-2 =?= SOME-11)
(sbSearch 11 derp-3 =?= SOME-11)
(sbSearch 11 derp-4 =?= SOME-11)
(sbSearch 11 derp-5 =?= SOME-11)
(sbSearch 11 derp-6 =?= SOME-11)
(sbSearch 66 derp-6 =?= SOME-66)
(sbSearch 77 derp-6 =?= NONE)

=?= derp-2 (N 11 11 E (L 22 22))
=?= derp-3 (N 22 22 (L 11 11) (L 33 33))
=?= derp-4 (N 22 22 (L 11 11) (N 33 33 E (L 44 44)))
=?= derp-5 (N 22 22 (L 11 11) (N 44 44 (L 33 33) (L 55 55)))

(NN x l r)=(N x x l r)
(LL x)=(L x x)

=?= (NN-44 (NN-22 LL-11 LL-33) (NN-55 E LL-66))
    (derp-6)

=?= (NN-44 (NN-22 LL-11 LL-33) (NN-66 LL-55 LL-77))
    (derp-7)

=?= (sbInsert 2 22 0)
    (sbSing 2 22)

ex=(NN-4 LL-2 LL-6)

=?= (sbInsert 4 {four} ex)
    (N 4 {four} (L 2 2) (L 6 6))

=?= (sbInsert 2 {two} ex)
    (N 4 4 (L 2 {two}) (L 6 6))

=?= (sbInsert 6 {six} ex)
    (N 4 4 (L 2 2) (L 6 {six}))

=?= (sbInsert 1 {one} ex)
    (N 4 4 (N 2 2 (L 1 {one}) E) (L 6 6))

=?= (sbInsert 2 {two} ex)   | NN-4 (L 2 {two})            | LL-6
=?= (sbInsert 3 {three} ex) | NN-4 (NN-2 E (L 3 {three})) | LL-6
=?= (sbInsert 5 {fiv} ex)   | NN-4 (NN-2 E E)             | NN-6 L-5-{fiv} E
=?= (sbInsert 6 {six} ex)   | NN-4 LL-2                   | L-6-{six}
=?= (sbInsert 7 {sev} ex)   | NN-4 LL-2                   | NN-6 E L-7-{sev}

= (deleteFindMax t)
: _ k v l r < sbOpen t
| Ifz r [[k v] l]
@ [km r2] deleteFindMax-r
| (km, balance k v l r2)

= (deleteFindMin t)
: _ k v l r < sbOpen t
| Ifz l [[k v] r]
@ [km l2] deleteFindMin-l
| (km, balance k v l2 r)

= (glue l r)
| Ifz l r
| Ifz r l
| If (Gth sbSize-l sbSize-r) ([[km m] l2] @ deleteFindMax l)(balance km m l2 r)
| else                       ([[km m] r2] @ deleteFindMin r)(balance km m l r2)

= (**ocase mb non som)  | Ifz mb non (**som Cdr-mb)

= (sbAlter f key x)
@ emptyCase | ocase f-NONE sbEmpty x&(sbSing key x)
: xsz xkey xval l r < sbCase x emptyCase
| Ix (Cmp key xkey)
++ balance xkey xval (sbAlter f key l) r
++  : newval < ocase f-(SOME xval) (glue l r)
    | xsz xkey newval l r
++ balance xkey xval l (sbAlter f key r)

; What is alterKnown?  Oh, where we know that the key is know to be there (so
; the function is passed the value not wrapped in a Maybe)

= (sbAlterKnown f key x)
: xsz xkey xval l r < sbCase x sbEmpty
| Ix (Cmp key xkey)
++ balance xkey xval (sbAlterKnown f key l) r
++ xsz xkey f-xval l r
++ balance xkey xval l (sbAlterKnown f key r)

= (sbDel key tree)
: xsz xkey xval l r < sbCase tree tree
| Ix (Cmp key xkey)
++ balance xkey xval (sbDel key l) r
++ glue l r
++ balance xkey xval l (sbDel key r)

(**sbSearchCase k t nf f)=(ocase (sbSearch k t) nf f)


(pack h t)=(Add (Lsh t 32) h)

(unpack v)=(Trunc 32 v, Rsh v 32)

= (newNat igo key nats apps table stack nat code)
@ nats  | sbInsert nat key nats
@ table | sbInsert key nat table
@ stack | [key stack]
@ key   | Inc key
@ state | Force [key nats apps table stack]
| igo state code

= (oldNat igo key nats apps table stack nat code)
@ res   | sbSearch nat nats
@ v     | fst res
@ stack | [v stack]
@ state | Force [key nats apps table stack]
| igo state code

= (insNat igo [key nats apps table stack] nat code)
@ res     | sbSearch nat nats
| Ifz res | newNat igo key nats apps table stack nat code
| else    | oldNat igo key nats apps table stack nat code

= (newApp igo key nats apps table h t stack code)
@ htw   | pack h t
@ apps  | sbInsert htw key   apps
@ table | sbInsert key [h t] table
@ stack | [key stack]
@ key   | Inc key
@ state | Force [key nats apps table stack]
| igo state code

= (oldApp igo key nats apps table h t stack code)
@ htw   | pack h t
@ res   | sbSearch htw apps
@ stack | (Ix 0 res, stack)
@ state | Force [key nats apps table stack]
| igo state code

= (rawInsApp igo key nats apps table h t stack code)
@ htw     | pack h t
@ res     | sbSearch htw apps
| Ifz res | newApp igo key nats apps table h t stack code
| else    | oldApp igo key nats apps table h t stack code

= (insApp igo [key nats apps table [t [h stack]]] code)
| **rawInsApp igo key nats apps table h t stack code

= (insPin igo [key nats apps table [i stack]] code)
| **rawInsApp igo key nats apps table 0 i stack code

= (igo !st code)
| Ix Hd-code
++ st
++ @ [c]   code (insPin igo st c)
++ @ [c]   code (insApp igo st c)
++ @ [n c] code (insNat igo st n c)

= (intern x)
| igo [1 0 0 0 0] (ival x E)

(bstKeyList x)=(listMap fst bstWalk-x)

(numAtoms x)=(| Hd | snd | intern x)

; ( (| intern 0 0 0 0 0 | ival (0 1) E) =?= 1 )

= (tables x)
@ [key nats apps table stack] (intern x)
++ stack
++ bstSave nats
++ bstSave apps
++ bstSave table

([0 1] =?= unpack 4294967296)
([2 3] =?= unpack 12884901890)
([1 1] =?= unpack 4294967297)
([0 2] =?= unpack 8589934592)
([3 2] =?= unpack 8589934595)

;=?= (tables ((0 1) 2))
; ++ [5 0]
; ++ [0 1 1 2 2 4]
; ++ [pack-1-2 3 pack-3-4 5]
; ++ [1 0  2 1  3 [1 2]  4 2  5 [3 4]]

; '] 0 = 0
; '] 1 = 1
; '] 2 = [1 1]
; '] 3 = [0 2]
; '] 4 = [3 2]

;=?= (tables (0 1-1 1-1))
; ++ [5 0]
; ++ [0 1 1 2]
; ++ [pack-2-2 3 pack-1-3 4 pack-4-3 5]
; ++ [1 0 2 1 3 [2 2] 4 [1 3] 5 [4 3]]

a=0
( numAtoms 0         =?= 1   )
b=0
( numAtoms ##0       =?= 0   )
c=0
( numAtoms ##1       =?= 1   )
d=0
( numAtoms Inc       =?= 4   )
e=0
( numAtoms (0 1 2 3) =?= 4   )
f=0
( numAtoms Add       =?= 13  )
g=0
( numAtoms count     =?= 29  ) ; 12s
( numAtoms rebuild   =?= 30  ) ; 13.5s
( numAtoms ival      =?= 46  ) ; 15s
h=0
( numAtoms ingestAst =?= 106 ) ; 43s
i=0
; numAtoms execBind  =?= 148 ) ;
j=0                            ;
; numAtoms doDefine  =?= 319 )
k=0
; numAtoms main      =?= 470 )
l=0





; ;3=?=4
; 
; 
; a=0
; (planSize 0 0           =?= 1)
; b=0
; (planSize 0 [0]         =?= 3)
; c=0
; (planSize 0 (##1 0 1 1) =?= 6)
; d=0
; (planSize 0 (x&x)       =?= 6)
; e=0
; (planSize 0 (##0 (0 1)) =?= 4)
; f=0
; (planSize 0 Add         =?= 220)
; g=0
; (planSize 0 planSize    =?= 2902)
; h=0
; (planSize 0 ingestAst   =?= 168371)
; i=0
; ; (planSize 0 execBind    =?= 1473422)
; ; j=0
; ; (planSize 0 doDefine    =?= 20472331)
; ; k=0
; ; (planSize 0 main        =?= 147588673)
; ; l=0
; 
; ;= (closureSize !n planSize o sz)
; ;| Ifz sz | planSize n Hd-o
; ;| closureSize (planSize n (Ix Dec-sz o)) planSize o Dec-sz
; 
; ;= (pinSize planSize n q planSize item)
; ;| planSize-(Inc n)-[item q]
; 
; ;= (appSize planSize n q o _ _)
; ;| closureSize Inc-n planSize o Sz-o
; 
; ;= (lawSize planSize n q _ _ b)
; ;| planSize-(Add 5 n)-[b q]
; 
; ;= (clzSize planSize i n q o)
; ;| Ifz i (planSize n ((Hd o, Idx 0 o), q)
; ;        | planSize
; 
; ;= (step planSize n q o)
; ;@ p pinSize-planSize-n-q
; ;@ l lawSize-planSize-n-q
; ;@ a appSize-planSize-n-q-o
; ;@ z (planSize Inc-n q)
; ;@ m _&(planSize Inc-n q)
; ;| ##3 p l a z m o
; 
; ;= (planSize !n q)
; ;| Ifz q n
; ;@ z Hd-q
; ;@ [o q] q
; ;| Ifz z (planSize n q o)
; ;| clzSize planSize Dec-z n q o
; 
; 
; ; (planSize planShape-0         =?= 1)
; ; (planSize planShape-(0 1)     =?= 2)
; ; (planSize planShape-(##1 1)   =?= 3)
; ; (planSize planShape-(Add 3)   =?= 162)
; ; (planSize planShape-ingestAst =?= 122667)
; ; (planSize planShape-execBind  =?= 1073539)
; ; (planSize planShape-doDefine  =?= 14913466)
; ; (planSize planShape-main      =?= 147588673)
; 
; ; type Key = Int
; ; data Node = ATOM Nat | NODE Key Key | HOLE Int
; ; nex   : Key
; ; atoms : Map Nat Key
; ; cells : Map Packed-(Key, Key) Key
; ; table : Map Key (Nat, Node)
; 
; (KZero _ = 0)
; (KZero2 _ _ = 0)
; (KZero3 _ _ _ = 0)
; 
; ; @ res | **searchTab node seen
; ; @ kix | Div res 2
; ; @ vix | Inc kix
; ; | If (Mod res 2)
;     ; @ key       | Ix vix seen
;     ; @ !refcount | Inc | snd | get tbl key
;     ; @ tbl       | put tbl key [node refcount]
;     ; | Force [tbl seen key]
; ; | else
;     ; @ key Sz-tbl
;     ; ++ Snoc tbl [node 1]
;     ; ++ Splice kix [node key] seen
;     ; ++ key
; 
; = (ibump nex table atoms cells key)
; | Trace [ibump nex table atoms cells key]
; @ table | sbAlterKnown cn&(Coup (Inc Hd-cn) cn) key table
; | Force [nex table atoms cells key]
; 
; = (iatomNew nex table atoms cells n)
; | Trace [iatomNew nex table atoms cells n]
; @ atoms | sbInsert n nex atoms
; @ table | sbInsert nex 1-n table
; | Force [Inc-nex table atoms cells nex]
; 
; = (iatom !nex !table !atoms !cells !n)
; | Trace [iatom nex table atoms cells n]
; @ fresh | iatomNew nex table atoms cells n
; : key < sbSearchCase n atoms fresh
; | ibump nex table atoms cells key
; 
; = (icellNew nex table atoms cells cellKey hkey tkey)
; | Trace [icellNew nex table atoms cells cellKey hkey tkey]
; @ node  | (hkey, tkey)
; @ key   | nex
; @ !nex  | Inc nex
; @ cells | sbInsert cellKey key cells
; @ table | sbInsert key 1-hkey-tkey table
; | Force [nex table atoms cells key]
; 
; = (icell nex table atoms cells hkey tkey)
; | Trace [icell nex table atoms cells hkey tkey]
; @ cellKey | Add tkey (Lsh hkey 32)
; @ fresh   | icellNew nex table atoms cells cellKey hkey tkey
; : key     < sbSearchCase cellKey cells fresh
; | ibump nex table atoms cells key
; 
; = (itail istep nex table atoms cells tl hkey)
; | Trace [itail istep nex table atoms cells tl hkey]
; @ [nex table atoms cells tkey] | istep nex table atoms cells tl
; | icell nex table atoms cells hkey tkey
; 
; = (ipair !istep !nex !table !atoms !cells !hd !tl)
; | Trace [ipair istep nex table atoms cells hd tl]
; @ [nex table atoms cells hkey] | istep nex table atoms cells hd
; | itail istep nex table atoms cells tl hkey
; 
; = (istep !nex !table !atoms !cells x)
; | Trace [istep nex table atoms cells x]
; ^ Trace [istep nex table atoms cells x {->} _] _
; | Br Sz-x ++ iatom nex table atoms cells x
;           ++ [nex table atoms cells fst-x]
; @ [hd tl] x
; | ipair istep nex table atoms cells hd tl
; 
; = (intern top) ; Array Any > Any > (DedupTable, DedupIndex)
; @ [nex table atoms cells key] (istep 1 0 0 0 planShape-top)
; | Force (table, atoms, cells)
; 
; ; (intern intern =?= intern intern)
; 
; ; planShape DeepSeq
; 
; hello={hi}
; 
; foo=0
; ;(planShape intern =?= planShape intern)
; bar=0
; ;(planShape planShape =?= planShape planShape)
; zaz=0
; ;(executeSire =?= executeSire)
; ;main={hi}
; ; (planShape doDefine =?= planShape doDefine)
; 
; ; main={hi}
; 
; = (ibump nex table atoms cells key)
; | Trace [ibump nex table atoms cells key]
; @ table | sbAlterKnown cn&(Coup (Inc Hd-cn) cn) key table
; | Force [nex table atoms cells key]
; 
; = (iatomNew nex table atoms cells n)
; | Trace [iatomNew nex table atoms cells n]
; @ atoms | sbInsert n nex atoms
; @ table | sbInsert nex 1-n table
; | Force [Inc-nex table atoms cells nex]
; 
; = (iatom !nex !table !atoms !cells !n)
; | Trace [iatom nex table atoms cells n]
; @ fresh | iatomNew nex table atoms cells n
; : key < sbSearchCase n atoms fresh
; | ibump nex table atoms cells key
; 
; = (icellNew nex table atoms cells cellKey hkey tkey)
; | Trace [icellNew nex table atoms cells cellKey hkey tkey]
; @ node  | (hkey, tkey)
; @ key   | nex
; @ !nex  | Inc nex
; @ cells | sbInsert cellKey key cells
; @ table | sbInsert key 1-hkey-tkey table
; | Force [nex table atoms cells key]
; 
; = (icell nex table atoms cells hkey tkey)
; | Trace [icell nex table atoms cells hkey tkey]
; @ cellKey | Add tkey (Lsh hkey 32)
; @ fresh   | icellNew nex table atoms cells cellKey hkey tkey
; : key     < sbSearchCase cellKey cells fresh
; | ibump nex table atoms cells key
; 
; = (itail istep nex table atoms cells tl hkey)
; | Trace [itail istep nex table atoms cells tl hkey]
; @ [nex table atoms cells tkey] | istep nex table atoms cells tl
; | icell nex table atoms cells hkey tkey
; 
; = (ipair !istep !nex !table !atoms !cells !hd !tl)
; | Trace [ipair istep nex table atoms cells hd tl]
; @ [nex table atoms cells hkey] | istep nex table atoms cells hd
; | itail istep nex table atoms cells tl hkey
; 
; = (istep !nex !table !atoms !cells x)
; | Trace [istep nex table atoms cells x]
; ^ Trace [istep nex table atoms cells x {->} _] _
; | Br Sz-x ++ iatom nex table atoms cells x
;           ++ [nex table atoms cells fst-x]
; @ [hd tl] x
; | ipair istep nex table atoms cells hd tl
; 
; ; = (intern top) ; Array Any > Any > (DedupTable, DedupIndex)
; ; @ [nex table atoms cells key] (istep 1 0 0 0 planShape-top)
; ; | Force (table, atoms, cells)
; ; | Ix Hd-code
; ; ++ acc
; ; ++ @ [k]   code | count acc     k    ; <0>
; ; ++ @ [k]   code | count Inc-acc k    ; mkapp
; ; ++ @ [n k] code | count acc     k    ; nat
; 
; = (bump key table)
; | sbAlterKnown cn&(Coup (Inc Hd-cn) cn) key table
; 
; ; = (ibump iturn n t as cs s k key)
; ; @ t | bump key t
; ; @ s | [key s]
; ; | iturn n t as cs s k
; 
; = (iatomOld iturn n t as cs s k _atom key)
; @ t | bump key t
; @ s | [key s]
; | iturn n t as cs s k
; 
; = (iatomNew iturn n t as cs s k atom _key)
; @ as | Force (sbInsert a n as)
; @ t  | Force (sbInsert n 1-a t)
; | iturn Inc-n t as cs [n s] k
; 
; = (icellOld iturn n t as cs s k _ck key _f _x)
; @ t   | bump key t
; @ s   | [key s]
; | iturn n t as cs s k
; 
; = (icellNew iturn n t as cs s k ck _key f x)
; @ cs | Force (sbInsert ck  n   cs)
; @ t  | Force (sbInsert n 1-f-x t)
; | iturn Inc-n t as cs [n s] k
; 
; = (iatom iturn !n !t !as !cs atom s k)
; @ res | sbSearch atom as
; | (Ifz res iatomNew iatomOld) iturn n t as cs s k atom fst-res
; 
; = (icell iturn n t as cs s k !f !x)
; @ ck  | Add x (Lsh f 32)
; @ res | sbSearch ck cs
; ^ (Ifz res icellNew icellOld) iturn n t as cs s k ck fst-res f x
; 
; = (ihole_ iturn n t as cs s k)
; @ [k] | k
; @ s   | [0 s]
; | iturn n t as cs s k
; 
; = (icell_ iturn n t as cs s k)
; @ [k] | k
; @ x   | fst s
; @ f   | fst snd-s
; @ s   | snd snd-s
; | icell iturn n t as cs s k f x
; 
; = (iatom_ iturn n t as cs s k)
; @ [a k] k
; | iatom iturn n t as cs s k a
; 
; = (idone_ iturn n t as cs s k)
; | 0 t as
; 
; = (iturn !n !t !as !cs !s k)
; | Ix Hd-k [idone_ ihole_ icell_ iatom_] iturn n t as cs s k
