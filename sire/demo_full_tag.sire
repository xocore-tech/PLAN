;;;; Copyright (c) 2026 xoCore Technologies
;;;; SPDX-License-Identifier: MIT
;;;; See LICENSE for full terms.
#### demo_full_tag <- xhttp

;;;; This is a partial port of `demo_full_tag_site.sire` to the new raw syscall
;;;; interface where we have our own minimal http stack written against
;;;; syscalls. This modifies the fulltag demo from being a Cog to being backed
;;;; just by one single threaded function, since we want to start with a
;;;; single threaded interpreter before we add actors to the low level
;;;; interface.

:| newboot
:| table
:| json
:| hitch
:| xhttp

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Design:
;
; Has one big HTTP server which just receives posts and gets. All POSTs perform
; plunder lookups. All GETs perform lookups in a cache of file for PUT
;
; - POST /usecdn   - sets demo to use CDN urls in the json
; - POST /uselocal - sets demo to use urls we serve
;
; - POST /learn 'content-type: application/json' [json file]
;
; - POST /count -> application/json back.
;
; - POST /search 'tags@[x y z]' -> application/json back.
;
; - GET / -> frontpage

; > TreeConfig
= imgmapConfig
@ minFanout 128
@ maxFanout | dec | mul 2 minFanout
| TREE_CONFIG
  minFanout
  maxFanout
  dec-minFanout
  dec-maxFanout
  minFanout
  maxFanout
  minFanout


; config for just the set part of the id setmap, optimized for nat -> bigset of
; nats.
= idsetConfig
@ minItems 1024
@ maxItems | dec | mul 2 minItems
@ minFanout 128
@ maxFanout | dec | mul 2 minFanout
| TREE_CONFIG
  minFanout
  maxFanout
  dec-minFanout
  dec-maxFanout
  minItems
  maxItems
  maxItems

; derpibooru's favicon
> Pin Bar
= favicon
| Pin
| bsCat
, x#{0000010001001010000000000000680400001600000028000000100000002000}
  x#{000001002000000000000004000000000000000000000000000000000000ffff}
  x#{ff00ffffff00ffffff00ffffff00ffffff00ffffff00ffffff00ffffff00ffff}
  x#{ff00edd673ffedd673ffeed97ee6ffffff00ffffff00ffffff0000000000ffff}
  x#{ff00ffffff00ffffff00ffffff00ffffff00ffffff00ffffff00fefdfb05edd6}
  x#{73ffedd673fffbf8e9ffedd673ffedd673ffffffff00ffffff0000000000ffff}
  x#{ff00ffffff00ffffff00ddc194ffffffff00ffffff00edd673feedd673ffedd6}
  x#{73ffedd673ffedd673ffedd673ffedd673fff9f2d445ffffff0000000000ffff}
  x#{ff00ffffff00ffffff00ddc194ffddc194ffedd673ffedd673fffbf8e9ffedd6}
  x#{73ffedd673ffedd673ffedd673ffedd673ffedd673ffffffff0000000000fdfb}
  x#{f213edd673ffedd673ffedd673ffddc194ffedd673ffedd673ffedd673ffedd6}
  x#{73ffedd673ffedd673fffbf8e9ffedd673ffedd673ffffffff0000000000ffff}
  x#{ff00ffffff00edd673ffedd673ffddc194ffddc194ffedd673ffedd673ffedd6}
  x#{73ffedd673ffedd673ffedd673ffedd673ffedd673ffefda82dd00000000ffff}
  x#{ff00ffffff00ffffff00ffffff00fefefe00ddc194fffefefd02ffffff00ffff}
  x#{ff00ffffff00fdfaef18edd673ffedd673ffedd673ffedd673ff00000000ffff}
  x#{ff00ffffff00ffffff00ffffff00ffffff00ffffff00ddc194ffffffff00ffff}
  x#{ff00ffffff00ffffff00ffffff00edd673fffbf8e9ffedd673ff00000000ffff}
  x#{ff00ffffff00ffffff00ffffff00ffffff00ffffff00ddc194fff1e5d360ffff}
  x#{ff00ffffff00ffffff00ffffff00edd673ffedd673ffedd673ff00000000ffff}
  x#{ff00ffffff00ffffff00ffffff00ffffff00ffffff00ffffff00ddc194fcffff}
  x#{ff00ffffff00ffffff00ffffff00ffffff00edd673ffedd673ff00000000ffff}
  x#{ff00ffffff00ffffff00ffffff00ffffff00ffffff00ffffff00ffffff00be85}
  x#{23fff9efdf7cffffff00ffffff00ffffff00edd673ffedd673ff00000000ffff}
  x#{ff00ffffff00ffffff00ffffff00ffffff00ffffff00ffffff00fdf9f428be85}
  x#{23fff3e1c1fffdfaf61effffff00ffffff00f0dd8cffedd673ff00000000ffff}
  x#{ff00ffffff00ffffff00ffffff00ffffff00ffffff00ffffff00f4e2c3ffddc1}
  x#{94ffddc194ffe1c79cfff4e2c3fff7ebd6a2edd673ffefda83dc00000000ffff}
  x#{ff00ffffff00ffffff00ffffff00ffffff00ffffff00ffffff00ffffff00f4e2}
  x#{c3ffddc194fff4e2c3ffffffff00ffffff00edd673ffffffff0000000000ffff}
  x#{ff00ffffff00ffffff00ffffff00ffffff00ffffff00ffffff00ffffff00f4e2}
  x#{c3ffffffff00f3e1c2ffffffff00ffffff00edd673ffffffff0000000000ffff}
  x#{ff00ffffff00ffffff00ffffff00ffffff00ffffff00ffffff00ffffff00ffff}
  x#{ff00ffffff00ffffff00ffffff00ffffff00ffffff00ffffff0000000000ff8f}
  x#{0000ff070000ec070000e003000080030000c0010000fbe10000fdf10000fdf1}
  x#{0000fef90000ff790000ff390000fe010000ff1b0000ff5b0000ffff0000}


; # typedef ContentType Bar ; TODO

; > HMap Str (ContentType, Pin Bar)
= startingFiles
; TODO: Figure out tuned config for files.
| hmSingleton
  largeConfig
  {/favicon.ico}
  [b#{image/x-icon} favicon]

;;;; #* # typedef Lock  | MVar ()

;  #* # typedef Url   | Bar
;  #* # typedef ImgId | Nat

# struct ImgRow
| IMG_ROW imgId/ImgId tags/(Row Str) url/Url

# struct CogState
| COG_STATE
  files/(HMap Str (ContentType, Pin Bar))
  fileBytes/Nat
  local/Bit
  imgCount/Nat
  pairCount/Nat
  imgs/(HMap ImgId ImgRow)
  tags/(HSetMap Tag Image)

getFiles=(Ix 0)
getFileBytes=(Ix 1)


> CogState
= newState
| COG_STATE
  startingFiles
  0
  FALSE
  0
  0
  (hmEmpty imgmapConfig)
  (hsmEmpty largeConfig idsetConfig)

= (mkPath path)
| strCat
| array
| CONS {/}
| lintersperse {/}
| stream path

=?= (mkPath [{a} {b}])
  {/a/b}

= (barElemIndexEnd e b)
| If (b == emptyBs) NONE
^ _ (dec | bsSz b)
? (loop i)
| If (Eq (bsIx i b) e) | SOME i
| Ifz i NONE
| loop (dec i)

; TODO: Next: need to make a bsElemIndexEnd
;
= (getFilename path)
: lastIdx < ocase (barElemIndexEnd {/} path)
            | Die [{weird filename} path]
| barDrop (Inc lastIdx) path

=?= (getFilename b#{http://blah/blah/two.html})
   b#{two.html}

; Set of images from derpibooru where there was a proper non-deleted API
; response, but the thumbnail file referenced was non-existent. Handle these as
; exceptions.
> Set ImgId
= missingImgs
++ 79135
++ 89769
++ 500313
++ 543877
++ 891477
++ 911039
++ 918505
++ 918535
++ 1078315
++ 1078318
++ 1772525
++ 2460696
++ 2460697
++ 2662803
++ 2668954
++ 2824778
++ 2825423
++ 2836375
++ 2863835
++ 2871055
++ 2899504
++ 2905776
++ 2915600
++ 2916074
++ 2918755
++ 2922373
++ 2929953
++ 2937212
++ 2938918
++ 2943107
++ 2944469
++ 2971526
++ 2983147
++ 2994310
++ 2999533
++ 3017754
++ 3019449
++ 3020597
++ 3023899
++ 3028888
++ 3030628
++ 3031483
++ 3031523
++ 3032025
++ 3032217
++ 3032519

;;; JSON Handling ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

= (unsafeGetJsonTable json)
| If | Ne JOBJ | Hd json
    | Die [{unsafeGetJsonTable: not a json object} json]
json

= (unsafeGetJsonNumber json)
| If | Ne JNUM | Hd json
    | Die [{unsafeGetJsonNumber: not a number} json]
| If | Ne Sz-json 1
    | Die [{unsafeGetJsonNumber: not an integer} json]
| Ix 0 json

= (unsafeTabLookup key t)
: v < ocase (tableLookup key t) | {unsafeTabLookup: missing key} key
v

= (unsafeGetJsonArray json)
| If | Ne JVEC | Hd json
    | Die [{unsafeGetJsonArray: not an array} json]
json

= (unsafeGetJsonStr json)
| If | Ne JSTR | Hd json
    | Die [{unsafeGetJsonStr: not a string} json]
| Ix 0 json

= (strictRow a)  | foldl (x _ & x) a a

= (jsonImgToRow jsonBS m)
@ id | unsafeGetJsonNumber | unsafeTabLookup "id" m
| If (setHas id missingImgs) NONE
@ !rawTags
  | strictRow
  | map unsafeGetJsonStr
  | unsafeGetJsonArray
  | unsafeTabLookup "tags" m
@ !thumbnailURL
  | unsafeGetJsonStr
  | unsafeTabLookup "thumb"
  | unsafeGetJsonTable
  | unsafeTabLookup "representations" m
| SOME [id rawTags thumbnailURL]

= (imgRowToTagTabSet [id tags _])
| tableFromPairs
| map tag&(tag, setSing id) tags

= (imgRowToPair imgRow@[id _ _])
[id imgRow]

# struct LearnData
| LEARN_DATA addRows/Any addImages/(Tab ImgId ImgRow) addTags/Any

= (catMaybes lis)
| array | lcatMaybes | stream lis

; > Bar > LearnData
= (parseLearn jsonBS)
| Profile parseLearn
@ !json | parseJson jsonBS
; | xtrace ["returned parse" json]
@ !rows
  | catMaybes
  | map m&(jsonImgToRow jsonBS | unsafeGetJsonTable m)
  | unsafeGetJsonArray
  | unsafeTabLookup "images"
  | unsafeGetJsonTable json
@ !addTags
  ;| trk {addTags}
  | foldl (tableUnionWith setUnion) emptySet
  | map imgRowToTagTabSet rows
@ !addImgs
  | tableFromPairs
  | map imgRowToPair rows
| LEARN_DATA rows addImgs addTags

;  abstype#Image ;; TODO: fix.  What is the real type?

;  > Pin CogState
;  > Pin LearnData
;  > (HMap ImgId ImgRow, HSetMap Tag Image, Nat, Nat)
= (calcLearnSt pcogstate plearndata)
| Profile calcLearnSt
@ [_ _ _ imgCount pairCount imgs tags] pcogstate
@ [rows addImgs addTags] plearndata
@ !nuImgs   | hmInsertMany addImgs imgs
@ !nuTags   | hsmInsertMany addTags tags
@ !imgCount  | Add imgCount  | len rows
@ !pairCount | Add pairCount | tableLen addTags
[nuImgs nuTags imgCount pairCount]

; > Bar > Maybe (Tab Str Json)
= (jsonMap jsonBS)
@ jsonN | natFromBs jsonBS
; TODO: What's the syntax for pulling apart a tag and the arguments? 
@ pv | parseValue jsonN 0
@ consumed | Hd pv
@ json | Ix 0 pv
| If (Ne consumed Bytes-jsonN) NONE
| If (Ne JOBJ | Hd json)       NONE
| SOME json

= (asJsonMap m)
| If (Ne JOBJ | Hd m) NONE
| SOME m

= (asJsonRow m)
| If (Ne JVEC | Hd m) NONE
| SOME m

= (asJsonNum m)
| If (Ne JNUM | Hd m) NONE
| If (Ne Sz-m 1)      NONE
| SOME | Ix 0 m

= (asJsonStr m)
| If (Ne JSTR | Hd m) NONE
| SOME | Ix 0 m

; List of commands we parse out of the incoming json
# simpledata Cmd
- STATUSCMD
- SEARCHCMD offset/Nat tags/Any

(**bindMaybe mVal k)=(maybeCase mVal NONE k)

;
; the json here being parsed is `{tag: "Search", contents: [array of str]}`.
;
> Bar > Maybe (Row Str)
= (parseSearch jsonBS)
: map < **bindMaybe (jsonMap jsonBS)
@ isSearch
    (SOME (JSTR b#{Search}) == tableLookup {tag} map)
| Ifz isSearch NONE
: jcontents < **bindMaybe (tableLookup {contents} map)
: content   < **bindMaybe (asJsonMap jcontents)
: joffset   < **bindMaybe (tableLookup {offset} content)
: offset    < **bindMaybe (asJsonNum joffset)
: jr        < **bindMaybe (tableLookup {tags} content)
: r         < **bindMaybe (asJsonRow jr)
: terms     < ^ (rowTraverse _ r)
              & (item pure)
              | If (Ne JSTR | Hd item) NONE
              | pure | Ix 0 item
| SOME (**SEARCHCMD offset terms)

; todo: this is doing the quick hack of just calling the old parseSearch; I
; think all of this should be rewritten when we have more user friendly json
; usage components.
> Bar > Maybe Cmd
= (parseCmd jsonBS)
: jm < **bindMaybe (jsonMap jsonBS)
: jt < **bindMaybe (tableLookup {tag} jm)
: tg < **bindMaybe (asJsonStr jt)
| If (Eq "Search" tg) | parseSearch jsonBS
| If (Eq "Status" tg) | SOME 0 ; STATUSCMD (but #data generated [0], not 0)
NONE

; TODO: The new JSON parser isn't very durable and will ##JsonErr in serveral
; invalid inputs instead of returning a NONE so it's easy to crash. Here's an
; old test that should pass.
;
; =?= NONE | parseCmd b#{"}

;  =?= NONE | parseCmd b#{{"x":3}}
;  =?= NONE | parseCmd b#{[]}

;  =?= (SOME (SEARCHCMD 5 ["x"]))
;    | parseCmd b#{{"tag": "Search", "contents": {"offset":5, "tags":["x"]}}}

;  =?= NONE
;    | parseCmd b#{{"tag": "bonk",   "contents": {"offset":0, "tags":["x"]}}}

;  =?= NONE
;    | parseCmd b#{{"tag": "Search", "contents": [234]}}

;  =?= SOME-(SEARCHCMD 8 [{x} {y}])
;    | parseCmd
;    | b#{{"tag": "Search", "contents": {"offset":8, "tags":["x", "y"]}}}

;  =?= (SOME 0)
;    | parseCmd b#{{"tag": "Status"}}

(tagToStr t)=(JSTR t)

= (buildStatus [_ fileBytes _ imgCount pairCount _ _])
| mkJOBJHack
++ ["bytes" (JNUM fileBytes)]
++ ["imgs" (JNUM imgCount)]
++ ["pairs" (JNUM pairCount)]

= (searchLookupTag tags tag)
@ hs | hsmLookup tag tags
| If hsNull-hs | LEFT tag
| RIGHT hs

= (fmapMaybe x f)     | And x | SOME | f | fst x

= (listMapMaybe f l) | lcatMaybes | lmap f l

; [hm hsm] [cord] > bar
= (doSearch st@[_ _ local _ _ imgs tags] [offset searchTags])
@ [missing idsets] | partition | map (searchLookupTag tags) searchTags
;| trk [%results missing idsets]
| If (Sz missing)
    ; send back the missing tags
    | mkJOBJHack
   ++ ["tag" (JSTR {BadTag})]
   ++ ["contents" (Coup JVEC | map tagToStr missing)]
   ++ ["status" (**buildStatus st)]
;
@ ids
  | hsMultiIntersect idsets
;
;| xtrace ["ids" ids]
@ targetIds
    | lsToList
    | lsTake 25
    | lsDrop offset ids
@ records
    | array
    ^ (listMapMaybe _ targetIds)
    & id
    | **fmapMaybe (hmLookup id imgs)
    & [_ _ url]
    @ path
      | Ifz local url
      ; generate a local server path from the id and the filename
      @ filename | getFilename url
      | mkPath [{img} (showNat id) filename]
    | JVEC (JNUM id) (JSTR path)
@ contents
    | mkJOBJHack
   ++ ["total" (JNUM lsLen-ids)]
   ++ ["offset" (JNUM offset)]
   ++ ["query" (Coup JVEC | map tagToStr searchTags)]
   ++ ["slice" (Coup JVEC records)]
| mkJOBJHack
++ ["tag" (JSTR "OK")]
++ ["contents" contents]
++ ["status" (**buildStatus st)]

= (doStatus st)
| mkJOBJHack
++ ["tag" (JSTR "Status")]
++ ["contents" (**buildStatus st)]

;  -----------------------------------------------------------------------

= simpleOkResponse
| HTTP_RESPONSE 200 b#{ok} emptyTable NONE

= (statelessOkResponseWithBody headers body)
| NO_PERSIST | HTTP_RESPONSE 200 b#{ok} headers (SOME body)

= simpleInputError
| NO_PERSIST | HTTP_RESPONSE 400 b#{bad request} emptyTable NONE

;; 
= (handleRequest st [verb path version headers] mybBody)
| Profile handleRequest
| If | Eq b#{POST} verb
    | If | Eq b#{/usecdn} path
        | PERSIST simpleOkResponse | handleRequest | localSet FALSE st
    | If | Eq b#{/uselocal} path
        | PERSIST simpleOkResponse | handleRequest | localSet TRUE st
    | If | Eq b#{/learn} path
        : body < ocase mybBody simpleInputError
        ; TODO: This elides the error checking that EVAL gives you: the server
        ; will just die on bad json instead.
        @ !learnData | parseLearn body
        @ ![nuImgs nuTags imgCount pairCount]
          | calcLearnSt st learnData
        ; | trk [=imgCount =pairCount]
        @ !newSt
          | imgCountSet imgCount
          | pairCountSet pairCount
          | imgsSet nuImgs
          | tagsSet nuTags
          | st
        | PERSIST simpleOkResponse | handleRequest newSt
    | If | Eq b#{/search} path
        : body < ocase mybBody simpleInputError
        : q    < ocase (parseCmd body) simpleInputError
        # simplecase q simpleInputError
        - STATUSCMD
          @ statusJson | **doStatus st
          @ statusBS   | printJson statusJson
          | statelessOkResponseWithBody emptyTable statusBS
        - SEARCHCMD offset tags
          @ searchJson | doSearch st [offset tags]
          @ searchBS   | printJson searchJson
          | statelessOkResponseWithBody emptyTable searchBS
    | xtrace ["Unknown"]
    simpleInputError
| If | Eq b#{PUT} verb
    : body < ocase mybBody simpleInputError
    @ barType | **fromSome b#{text/plain}
              | tableLookup b#{Content-Type} headers
    @ newTotalSize | add (barLen body) | getFileBytes st
    @ files | hmInsert (natFromBs path) [barType (Pin body)] | getFiles st
    | PERSIST | HTTP_RESPONSE 201 b#{done} emptyTable NONE
    | handleRequest
    | fileBytesSet newTotalSize
    | filesSet files
    | st
| If | Eq b#{GET} verb
  : record < ocase | hmLookup (natFromBs path) (getFiles st)
             | NO_PERSIST
             | HTTP_RESPONSE 404 b#{File Not Found} emptyTable NONE
  @ [type pcontent] record
  @ content | Unpin pcontent
  @ headers | tableSing b#{Content-Type} type
  | statelessOkResponseWithBody headers content
;
simpleInputError

= (main args)
| runHttpServer (handleRequest newState) args
